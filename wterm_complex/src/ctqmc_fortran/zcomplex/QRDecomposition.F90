! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.

!> Collects tools for working with the (pivoted) QR decomposition.
module MQRDecompositionZ
    use iso_c_binding, only: c_double, c_double_complex
    use MBLAS
    use MExtRangeZ
    use MLAPACK
    use MPermutation
    use Testing
    implicit none
    private

    !> Parameters of a plane rotation, represented by the 2 x 2 matrix:
    !!
    !!     [        c,  s ]
    !!     [ -conjg(s), c ]
    !!
    type, public :: ZPlaneRotation
        real(c_double) :: c
        complex(c_double_complex) :: s
    end type

    !>     rot = conjg(rot_a)
    !!
    !! Returns the complex conjugate rotation.
    interface conjg
        module procedure conjg_rot
    end interface
    public conjg

    !>     det = qr_det(qr, tau, [jpiv])
    !!
    !! Computes the determinant of a matrix from its QR decomposition. `qr` is
    !! the matrix combining R and the Householder vectors of Q and `tau`
    !! are the factors for the reflectors (output of ZGEQRF). If pivoting is
    !! used `jpiv` is the permutation needed (output of GEQP3).
    interface qr_det
        module procedure qr_det_nopivot, qr_det_pivot
    end interface
    public qr_det

    !>     det = householder_det(tau)
    !!
    !! Determinant of a Householder reflector `1 - tau * v * v**H`, where `v`
    !! is some unit vector.  If given a vector, gives the product of all
    !! reflectors determinants.
    interface householder_det
        module procedure householder_det_one, householder_det_vec
    end interface
    public householder_det

    !>     det = product_of_diagonal(a)
    !!
    !! Product of diagonal.
    interface product_of_diagonal
        module procedure p_product_of_diagonal
    end interface
    public product_of_diagonal

    !>     call qr_hessenberg(k, H, ldh, q)
    !!
    !! Reduce a `m x n` matrix `H` which is `k`-Hessenberg, i.e., has zeros
    !! below the k-th subdiagonal, to upper triangular form. The matrix is of
    !! size `(ldh, n)`. The corresponding Givens rotations are stored in `q`,
    !! which must be a `k x (n-1)` array, and on exit `H` is overridden with
    !! the corresponding upper triangular form.
    interface qr_hessenberg
        module procedure p_qr_hessenberg
    end interface
    public qr_hessenberg

    !>     call rotate_q(Q, ldq, G)
    !!
    !! Rotate Q corresponding to a set of Givens rotation.
    interface rotate_q
        module procedure p_rotate_q
    end interface
    public rotate_q

    !>     call q_diagonalize(Q, ldq, G)
    !!
    !! Reduce a `m x n` matrix `Q`, where the rows are orthogonal, to a
    !! diagonal matrix using a series of givens rotations `G` applied from
    !! the right.
    interface q_diagonalize
        module procedure p_q_diagonalize
    end interface
    public q_diagonalize

    !>     call rotate_back_q(Q, ldq, G)
    !!
    !! Rotate Q corresponding to a set of Givens rotation in the inverse order.
    interface rotate_back_q
        module procedure p_rotate_back_q
    end interface
    public rotate_back_q

    !>     call rotate_r(R, ldr, giv)
    !!
    !! Apply rotations obtained from diagonalizing Q to a right-triangular
    !! matrix R in order to make it k-Hessenberg.
    interface rotate_r
        module procedure p_rotate_r
    end interface
    public rotate_r

    !>     t = is_upper_triangular(a, [rtol])
    !!
    !! Check if a matrix is upper triangular
    interface is_upper_triangular
        module procedure p_is_upper_triangular
    end interface
    public is_upper_triangular

    complex(c_double_complex), parameter :: ONE = 1

contains

    pure function conjg_rot(a) result(r)
        type(ZPlaneRotation), intent(in) :: a
        type(ZPlaneRotation) :: r

        r%c = a%c
        r%s = conjg(a%s)
    end

    function qr_det_pivot(qr, tau, jpiv) result(det)
        complex(c_double_complex), intent(in) :: qr(:, :), tau(:)
        integer, intent(in) :: jpiv(:)
        type(ZExtRange) :: det

        if (size(qr, 1) /= size(jpiv)) &
            error stop 'jpiv has invalid size'

        det = qr_det_nopivot(qr, tau)

        ! Permutation array
        if (perm_parity(jpiv)) &
            det = -det
    end

    function qr_det_nopivot(qr, tau) result(det)
        complex(c_double_complex), intent(in) :: qr(:, :), tau(:)
        type(ZExtRange) :: det

        if (size(qr, 1) /= size(tau)) &
            error stop 'tau has invalid size'

        ! The determinant of the QR decomposition is det(QR) = det(Q) det(R).
        ! The simple part is the upper triangular matrix R, which is simply
        ! the product of the diagonal.
        det = p_product_of_diagonal(qr)

        ! The much trickier part is Q. In LAPACK, Q is a product of Householder
        ! reflectors, Q = H(n) * H(n-1) * ... * H(1).
        det = det * householder_det_vec(tau)
    end

    function p_product_of_diagonal(qr) result(det)
        complex(c_double_complex), intent(in) :: qr(:, :)
        type(ZExtRange) :: det
        integer :: i

        if (size(qr, 1) /= size(qr, 2)) &
            error stop 'Matrix must be square'

        if (size(qr, 1) == 0) then
            det = ONE
            return
        endif

        det = qr(1, 1)
        do i = 2, size(qr, 1)
            det = det * qr(i, i)
        enddo
    end function

    pure function householder_det_vec(tau) result(det)
        complex(c_double_complex), intent(in) :: tau(:)
        complex(c_double_complex) :: det
        integer :: i

        det = ONE
        do i = 1, size(tau)
            det = det * householder_det_one(tau(i))
        enddo
    end

    pure function householder_det_one(tau) result(det)
        complex(c_double_complex), value :: tau
        complex(c_double_complex) :: det

        ! A Householder reflector is given by H = I - tau * v * vH, so by the
        ! Woodbury formula, we have det(H) = 1 - tau * norm(v)**2.  Since H
        ! must be unitary, we have abs2(det(H)) = 1.
        if (tau == 0) then
            det = 1
        else
            ! For complex matrices, this implies the following expressions
            ! (see [1] for a discussion)
            ! [1] https://math.stackexchange.com/questions/693948
            tau = tau / abs(tau)
            det = -tau * tau
        endif
    end

    subroutine p_qr_hessenberg(k, h, ldh, g)
        integer, intent(in) :: k, ldh
        complex(c_double_complex), intent(inout) :: h(:, :)
        type(ZPlaneRotation), intent(out) :: g(:, :)

        integer :: i, j, l, m, n
        type(ZPlaneRotation) :: gcurr

        m = size(h, 1)
        n = size(h, 2)
        if (size(g, 1) /= k .or. size(g, 2) /= n - 1) &
            error stop 'Invalid size of g'

        ! Cost O(k*m*n)
        do j = 1, n - 1
            do l = k, 1, -1
                i = j + l - 1
                if (i >= m) then
                    g(l, j)%c = 1
                    g(l, j)%s = 0
                else
                    call rotate_inplace(h(i, j), h(i+1, j), gcurr)

                    ! XXX requires H to be contiguous
                    call ZROT(n-j, h(i, j+1), ldh, h(i+1, j+1), ldh, &
                             gcurr%c, gcurr%s)
                    g(l, j) = gcurr
                endif
            enddo
        enddo
    end subroutine

    subroutine p_rotate_q(q, ldq, g)
        integer, intent(in) :: ldq
        complex(c_double_complex), intent(inout) :: q(:, :)
        type(ZPlaneRotation), intent(in) :: g(:, :)

        type(ZPlaneRotation) :: gadj
        integer :: i, j, k, l, m, n

        m = size(q, 1)
        n = size(q, 2)
        if (size(g, 2) /= n - 1) &
            error stop 'Invalid size of g'
        k = size(g, 1)

        ! We apply the adjoint of all the transformations from the right. We
        ! have to apply in the *same* order as we have applied them to the
        ! Householder matrix, since:
        !
        !     Q G(1)^* G(2)^* ... G(2) G(1) H = Q' R
        !
        do j = 1, n - 1
            do l = k, 1, -1
                i = j + l - 1
                if (i >= n) &
                    cycle

                gadj = conjg(g(l, j))
                call ZROT(m, q(1, i), 1, q(1, i+1), 1, gadj%c, gadj%s)
            enddo
        enddo
    end subroutine

    subroutine p_q_diagonalize(q, ldq, giv)
        integer, intent(in) :: ldq
        complex(c_double_complex), intent(inout) :: q(:, :)
        type(ZPlaneRotation), intent(out) :: giv(:, :)

        integer :: i, j, d, m, n
        type(ZPlaneRotation) :: gadj

        m = size(q, 1)
        n = size(q, 2)
        if (size(giv, 1) /= m .or. size(giv, 2) /= n - 1) &
            error stop 'Invalid size of givens array'

        do d = n-1, 1, -1
            do i = 1, m
                j = d + i - 1
                if (j >= n) then
                    giv(i, d)%c = 1
                    giv(i, d)%s = 0
                else
                    call rotate_inplace(q(i, j), q(i, j+1), gadj)
                    if (i < m) then
                        call ZROT(m - i, q(i+1, j), 1, q(i+1, j+1), 1, &
                                 gadj%c, gadj%s)
                    endif
                    giv(i, d) = conjg(gadj)
                endif
            enddo
        enddo
    end subroutine

    subroutine p_rotate_back_q(q, ldq, g)
        integer, intent(in) :: ldq
        complex(c_double_complex), intent(inout) :: q(:, :)
        type(ZPlaneRotation), intent(in) :: g(:, :)

        type(ZPlaneRotation) :: gadj
        integer :: i, j, k, l, n, m

        m = size(q, 1)
        n = size(q, 2)
        if (size(g, 2) /= n - 1) &
            error stop 'Invalid size of g'
        k = size(g, 1)

        ! We apply the adjoint of all the transformations from the right. We
        ! have to apply in the *same* order as we have applied them to the
        ! Householder matrix, since:
        !
        !     Q G(1)^* G(2)^* ... G(2) G(1) H = Q' R
        !
        do j = n - 1, 1, -1
            do l = 1, k
                i = j + l - 1
                if (i >= n) &
                    exit

                gadj = conjg(g(l, j))
                call ZROT(m, q(1, i), 1, q(1, i+1), 1, gadj%c, gadj%s)
            enddo
        enddo
    end subroutine

    subroutine p_rotate_r(r, ldr, giv)
        integer, intent(in) :: ldr
        complex(c_double_complex), intent(inout) :: r(:, :)
        type(ZPlaneRotation), intent(in) :: giv(:, :)

        integer :: i, j, d, k, n, m
        type(ZPlaneRotation) :: gcurr

        n = size(r, 1)
        m = size(r, 2)
        if (size(giv, 2) /= n - 1) &
            error stop 'Invalid size of givens array'
        if (m == 0) &
            return

        k = size(giv, 1)
        do d = n-1, 1, -1
            do i = 1, k
                j = d + i - 1
                if (j >= n) &
                    exit

                gcurr = giv(i, d)
                ! XXX only rotate upper diagonal for two-fold speedup
                call ZROT(m, r(j, 1), ldr, r(j+1, 1), ldr, gcurr%c, gcurr%s)
            enddo
        enddo
    end subroutine

    subroutine rotate_inplace(f, g, rot)
        complex(c_double_complex), intent(inout) :: f, g
        type(ZPlaneRotation), intent(out) :: rot
        complex(c_double_complex) :: r

        call ZLARTG(f, g, rot%c, rot%s, r)
        f = r
        g = 0
    end subroutine


    logical function p_is_upper_triangular(a, rtol) result(test)
        complex(c_double_complex), intent(in) :: a(:, :)
        real(c_double), intent(in), optional :: rtol

        integer :: i, j
        real(c_double) :: magn, thr

        test = .true.
        if (present(rtol)) then
            magn = maxval(abs(a)) * sqrt(dble(size(a)))
            thr = rtol * magn
        else
            thr = 0
        endif
        do j = 1, size(a, 2)
            do i = j + 1, size(a, 1)
                if (.not. (abs(a(i, j)) <= thr)) then
                    test = .false.
                    return
                endif
            enddo
        enddo
    end

end module
