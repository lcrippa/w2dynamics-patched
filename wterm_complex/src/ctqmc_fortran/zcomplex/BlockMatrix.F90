! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.

module MBlockMatrixZ
    use iso_c_binding, only: c_double, c_double_complex
    use MComplexNumbers
    use MExtRangeZ
    use MPermutation
    use MSorting
    use MUpdatableMatrixZ
    use Testing
    implicit none
    private

    !> Updatable block-diagonal matrix together with inverse and determinant
    !!
    !! Stores a block-diagonal square matrix, together with its
    !! inverse and its determinant in such a way as to facilitate low-rank
    !! updates as well as row/column addition and removal without frequent
    !! reallocations.
    !!
    !! Use `getmatrix`, `get_det` and `getinv` to get the matrix, its
    !! determinant, and its inverse, respectively.
    !!
    !! Alterations can be made using updates, which come in two stages: the
    !! are proposed by the `propose_*` functions, which propose an update to
    !! the matrix, but do not change it.  After proposal, the determinant of
    !! the proposed update is available using `get_det`.  The proposal can
    !! be accepted using `accept_update()`.
    type, public :: ZBlockMatrix
        private
        integer :: nblocks = 0, size = 0
        type(ZExtRange) :: det
        type(ZUpdatableMatrix), allocatable :: block(:)
        integer, allocatable :: offset(:)
        integer, allocatable :: lookup(:)
    end type

    !> Base type for the block matrix update.
    !!
    !! Use propose_* routines to propose actual updates. You can erase the
    !! concrete update type by setting a pointer of type(ZBlockUpdateBase)
    !! and then use get_det() and accept_update().
    type, abstract, public :: ZBlockUpdateBase
        private
        type(ZBlockMatrix), pointer :: target
        type(ZExtRange) :: det
        logical :: allowed
        logical, allocatable :: active(:)
    contains
        private
        procedure(base_accept_update), deferred :: accept_update
    end type

    abstract interface
        subroutine base_accept_update(self)
            import :: ZBlockUpdateBase
            class(ZBlockUpdateBase), intent(inout) :: self
        end
    end interface

    !> Update to replace the block matrix by another.
    !!
    !! Update which replaces the matrix by another matrix, not necessarily of
    !! the same size as the current one.  Use `propose_replace_matrix()` to
    !! propose this update.
    type, extends(ZBlockUpdateBase), public :: ZBlockReplace
        private
        type(ZMatrixReplace), allocatable :: block(:)
        integer :: size
        integer, allocatable :: offset(:)
        integer, allocatable :: lookup(:)
    contains
        private
        procedure, non_overridable :: accept_update => p_repl_accept
    end type

    !> Update to grow the block smatrix.
    !!
    !! Update which inserts a set of rows and columns at arbitrary position in
    !! the matrix.  Use `propose_grow_matrix()` to propose this update.
    type, extends(ZBlockUpdateBase), public :: ZBlockGrow
        private
        type(ZMatrixGrow), allocatable :: block(:)
        integer :: size
        integer, allocatable :: offset(:)
        integer, allocatable :: lookup(:)
    contains
        private
        procedure, non_overridable :: accept_update => p_grow_accept
    end type

    !> Update to shrink the block matrix.
    !!
    !! Update which removes a set of rows and columns at arbitrary position
    !! from the matrix.  Use `propose_shrink_matrix()` to propose this update.
    type, extends(ZBlockUpdateBase), public :: ZBlockShrink
        private
        type(ZMatrixShrink), allocatable :: block(:)
        integer :: size, rank
        integer, allocatable :: offset(:)
        integer, allocatable :: lookup(:)
    contains
        private
        procedure, non_overridable :: accept_update => p_shrink_accept
    end type

    !> Replace set of rows in the block matrix.
    !!
    !! Replace a set of rows by another set, potentially at a different
    !! position in the matrix.  Use `propose_replace_rows()` to propose this
    !! update.
    type, extends(ZBlockUpdateBase), public :: ZBlockReplaceRows
        private
        type(ZReplaceRows), allocatable :: block(:)
        integer :: size, rank
    contains
        private
        procedure, non_overridable :: accept_update => p_rows_accept
    end type

    !> Replace set of columns in the block matrix.
    !!
    !! Replace a set of columns by another set, potentially at a different
    !! position in the matrix.  Use `propose_replace_cols()` to propose this
    !! update.
    type, extends(ZBlockUpdateBase), public :: ZBlockReplaceCols
        private
        type(ZReplaceCols), allocatable :: block(:)
        integer :: size, rank
    contains
        private
        procedure, non_overridable :: accept_update => p_cols_accept
    end type

    !> Scale and permute rows and columns in a block matrix.
    !!
    !! Scale the rows and columns by a set of vectors, then permute rows and
    !! columns, i.e., multiply the matrix from left and right by generalized
    !! permutation matrices.  Use `propose_permute_matrix()` to propose this
    !! update.
    type, extends(ZBlockUpdateBase), public :: ZBlockPermute
        private
        type(ZMatrixPermute), allocatable :: block(:)
        integer :: size
    contains
        private
        procedure, non_overridable :: accept_update => p_permute_accept
    end type

    interface initialize
        module procedure p_init, p_repl_init, p_grow_init, p_shrink_init, &
                         p_rows_init, p_cols_init, p_permute_init
    end interface
    public initialize

    interface size
        module procedure p_size
    end interface
    public size

    interface get_det
        module procedure p_det, p_base_det
    end interface
    public get_det

    interface getinv
        module procedure p_inv
    end interface
    public getinv

    interface copyinv
        module procedure p_copyinv
    end interface
    public copyinv

    interface getmatrix
        module procedure p_getmatrix
    end interface
    public getmatrix

    interface copymatrix
        module procedure p_copymatrix
    end interface
    public copymatrix

    interface setmatrix
        module procedure p_setmatrix
    end interface
    public setmatrix

    interface verify
        module procedure p_verify
    end interface
    public verify

    interface propose_replace_matrix
        module procedure p_repl_propose
    end interface
    public propose_replace_matrix

    interface propose_grow_matrix
        module procedure p_grow_propose
    end interface
    public propose_grow_matrix

    interface propose_shrink_matrix
        module procedure p_shrink_propose
    end interface
    public propose_shrink_matrix

    interface propose_replace_rows
        module procedure p_rows_propose
    end interface
    public propose_replace_rows

    interface propose_replace_cols
        module procedure p_cols_propose
    end interface
    public propose_replace_cols

    interface propose_permute_matrix
        module procedure p_permute_propose
    end interface
    public propose_permute_matrix

    interface accept_update
        module procedure p_accept_update
    end interface
    public accept_update

    interface is_update_allowed
        module procedure p_base_allowed
    end interface
    public is_update_allowed

    interface isinitialized
        module procedure p_isinit, p_repl_isinit, p_grow_isinit, &
                         p_shrink_isinit, p_rows_isinit, p_cols_isinit, &
                         p_permute_isinit
    end interface

    interface setsize
        module procedure p_setsize, p_repl_setsize, p_grow_setsize, &
                         p_shrink_setsize, p_rows_setsize, p_cols_setsize, &
                         p_permute_setsize
    end interface

    complex(c_double_complex), parameter :: ONE = 1
    complex(c_double_complex), parameter :: ZERO = 0

contains

    pure logical function p_isinit(self)
        type(ZBlockMatrix), intent(in) :: self

        p_isinit = allocated(self%block)
    end

    subroutine p_init(self, nblocks)
        type(ZBlockMatrix), intent(inout) :: self
        integer, intent(in) :: nblocks

        if (nblocks < 0) &
            error stop 'Number of blocks must be non-negative'

        self%nblocks = nblocks
        self%size = 0
        self%det = ONE
        allocate(self%block(self%nblocks))
        allocate(self%offset(self%nblocks + 1))
        allocate(self%lookup(4))

        self%offset(:) = 0
        self%lookup(:) = -4711
    end

    pure integer function p_size(self)
        type(ZBlockMatrix), intent(in) :: self

        if (isinitialized(self)) then
            p_size = self%size
        else
            p_size = -1
        endif
    end

    subroutine p_setsize(self, newsize)
        type(ZBlockMatrix), intent(inout) :: self
        integer, intent(in) :: newsize
        integer :: maxsize

        integer, allocatable :: lookup_save(:)

        maxsize = size(self%lookup)
        if (newsize > maxsize) then
            call move_alloc(self%lookup, lookup_save)
            allocate(self%lookup(newsize + 1))
            self%lookup(:maxsize) = lookup_save
        endif
        self%lookup(newsize+1:) = -4711
        self%size = newsize
    end

    pure function p_det(self) result(det)
        type(ZBlockMatrix), intent(in) :: self
        type(ZExtRange) :: det

        if (isinitialized(self)) then
            det = self%det
        else
            det = nan(ONE)
        endif
    end

    function p_inv(self) result(r)
        type(ZBlockMatrix), intent(in) :: self
        complex(c_double_complex), allocatable :: r(:, :)

        allocate(r(self%size, self%size))
        call copyinv(self, r)
    end

    subroutine p_copyinv(self, buf)
        type(ZBlockMatrix), intent(in) :: self
        complex(c_double_complex), intent(out) :: buf(:, :)

        integer :: b, bstart, bend

        if (size(buf,1) /= self%size .or. size(buf,2) /= self%size) &
            error stop 'size mismatch'

        buf(:, :) = 0
        do b = 1, self%nblocks
            bstart = self%offset(b) + 1
            bend = self%offset(b) + size(self%block(b))
            call copyinv(self%block(b), buf(bstart:bend, bstart:bend))
        end do
    end

    function p_getmatrix(self) result(r)
        type(ZBlockMatrix), intent(in) :: self
        complex(c_double_complex), allocatable :: r(:, :)

        allocate(r(self%size, self%size))
        call copymatrix(self, r)
    end

    subroutine p_copymatrix(self, buf)
        type(ZBlockMatrix), intent(in) :: self
        complex(c_double_complex), intent(out) :: buf(:, :)

        integer :: b, bstart, bend

        if (size(buf,1) /= self%size .or. size(buf,2) /= self%size) &
            error stop 'size mismatch'

        buf(:, :) = 0
        do b = 1, self%nblocks
            bstart = self%offset(b) + 1
            bend = self%offset(b) + size(self%block(b))
            call copymatrix(self%block(b), buf(bstart:bend, bstart:bend))
        end do
    end

    subroutine p_setmatrix(self, blockidx, a)
        type(ZBlockMatrix), intent(inout) :: self
        integer, intent(in) :: blockidx(:)
        complex(c_double_complex), intent(in) :: a(:, :)

        integer :: b, icur, iend

        if (size(a,1) /= size(a, 2)) &
            error stop 'matrix must be square'
        if (size(blockidx) /= size(a,1)) &
            error stop 'inconsistent size of block indices and matrix'

        call p_compute_offsets(blockidx, self%offset)
        do b = 1, self%nblocks
            icur = self%offset(b)
            iend = self%offset(b+1)
            call check_block(a(:, icur+1:iend), icur, iend)
            call setmatrix(self%block(b), a(icur+1:iend, icur+1:iend))
        end do
        self%lookup = blockidx
        self%det = p_recompute_det(self)
        self%size = size(blockidx)
    end

    subroutine check_block(arr, icur, iend)
        complex(c_double_complex), intent(in) :: arr(:, :)
        integer, intent(in) :: icur, iend

        integer :: i, j

        do j = 1, size(arr, 2)
            do i = 1, icur
                if (arr(i, j) /= 0) &
                    error stop 'nonzero preceding element'
            end do
            do i = iend + 1, size(arr, 1)
                if (arr(i, j) /= 0) &
                    error stop 'nonzero trailing element'
            end do
        end do
    end

    subroutine p_compute_offsets(blockidx, offsets)
        integer, intent(in) :: blockidx(:)
        integer, intent(out) :: offsets(:)

        integer :: currb, thisb, i

        currb = 0
        do i = 1, size(blockidx)
            thisb = blockidx(i)
            if (thisb < 1 .or. thisb >= size(offsets)) then
                error stop 'invalid block index'
            else if (thisb < currb) then
                error stop 'block indices must be sorted'
            else if (thisb > currb) then
                offsets(currb+1:thisb) = i - 1
                currb = thisb
            endif
        enddo
        offsets(currb+1:) = size(blockidx)
    end

    subroutine p_compute_lookup(offset, blockidx)
        integer, intent(in) :: offset(:)
        integer, intent(out) :: blockidx(:)

        integer :: i, b

        blockidx(:) = 0
        do i = 1, size(blockidx)
            do b = 1, size(offset) - 1
                if (i > offset(b)) &
                    blockidx(i) = blockidx(i) + 1
            enddo
        enddo
    end subroutine

    subroutine p_verify(self, rtol)
        type(ZBlockMatrix), intent(in) :: self
        real(c_double), intent(in), optional :: rtol

        integer :: b, offset

        call assert_equal(isinitialized(self), .true.)
        call assert_close(limrange(p_recompute_det(self) / self%det), ONE, &
                          rtol=rtol)

        offset = 0
        do b = 1, self%nblocks
            call assert_equal(self%offset(b), offset)
            if (.not. all(self%lookup(offset+1:offset+size(self%block(b))) == b)) &
                call terminate('invalid lookup')
            call verify(self%block(b), rtol=rtol)
            offset = offset + size(self%block(b))
        enddo
        call assert_equal(self%size, offset)
        call assert_equal(self%offset(b), offset)
    end

    function p_recompute_det(self) result(det)
        type(ZBlockMatrix), intent(in) :: self
        type(ZExtRange) :: det

        integer :: b

        det = ONE
        do b = 1, self%nblocks
            det = det * get_det(self%block(b))
        enddo
    end

    ! -------------------------------------------------------------------------
    ! BLOCK MATRIX UPDATE BASE

    pure function p_base_det(self) result(r)
        class(ZBlockUpdateBase), intent(in) :: self
        type(ZExtRange) :: r

        r = self%det
    end

    pure logical function p_base_allowed(self) result(allowed)
        class(ZBlockUpdateBase), intent(in) :: self

        allowed = self%allowed
    end

    subroutine p_accept_update(self)
        class(ZBlockUpdateBase), intent(inout) :: self

        call self%accept_update()
    end

    ! -------------------------------------------------------------------------
    ! BLOCK MATRIX REPLACE

    pure logical function p_repl_isinit(self)
        type(ZBlockReplace), intent(in) :: self

        p_repl_isinit = allocated(self%block)
    end

    subroutine p_repl_init(self, nblocks)
        type(ZBlockReplace), intent(inout) :: self
        integer, intent(in) :: nblocks

        if (isinitialized(self)) return
        self%target => null()
        self%det = ZERO
        self%allowed = .false.
        allocate(self%active(nblocks))
        allocate(self%block(nblocks))
        allocate(self%offset(nblocks + 1))
        allocate(self%lookup(4))
        self%active(:) = .false.
        self%lookup(:) = -4711
        self%offset(:) = -4711
    end

    subroutine p_repl_setsize(self, newsize)
        type(ZBlockReplace), intent(inout) :: self
        integer, intent(in) :: newsize
        integer :: maxsize

        maxsize = size(self%lookup)
        if (newsize > maxsize) then
            deallocate(self%lookup)
            allocate(self%lookup(newsize + 1))
            self%lookup(:) = -4711
        endif
        self%size = newsize
    end

    subroutine p_repl_propose(self, t, iblock, jblock, a)
        type(ZBlockReplace), intent(inout) :: self
        type(ZBlockMatrix), intent(inout), target :: t
        integer, intent(in) :: iblock(:), jblock(:)
        complex(c_double_complex), intent(in) :: a(:, :)

        integer :: b, icur, iend

        if (.not. isinitialized(t)) &
            error stop 'block matrix not initialized'
        if (size(a,1) /= size(a, 2)) &
            error stop 'matrix must be square'
        if (size(iblock) /= size(a,1) .or. size(jblock) /= size(a,1)) &
            error stop 'inconsistent size of block indices and matrix'

        call p_repl_init(self, t%nblocks)
        call setsize(self, size(iblock))
        self%target => t

        ! The second call overrides the first, but we're mostly interested
        ! in the error checking that the function does
        call p_compute_offsets(iblock, self%offset)
        call p_compute_offsets(jblock, self%offset)

        ! It makes sense to allow moves which would break the block structure,
        ! since it makes the higher-level logic simpler. We may however NEVER
        ! accept such a move
        self%allowed = all(iblock == jblock)
        if (.not. self%allowed) then
            self%det = ZERO
            return
        endif

        self%lookup(:self%size) = iblock
        self%det = ONE

        do b = 1, self%target%nblocks
            icur = self%offset(b) + 1
            iend = self%offset(b+1)

            call propose_replace_matrix( &
                    self%block(b), self%target%block(b), &
                    a(icur:iend, icur:iend))
            self%det = self%det * get_det(self%block(b))
            self%active(b) = .true.
        end do
    end

    subroutine p_repl_accept(self)
        class(ZBlockReplace), intent(inout) :: self
        integer :: b

        if (.not. associated(self%target)) &
            error stop 'No move proposed'
        if (.not. self%allowed) &
            error stop 'Cannot accept move which violates symmetry'

        do b = 1, self%target%nblocks
            if (self%active(b)) &
                call accept_update(self%block(b))
        end do

        call setsize(self%target, self%size)
        self%target%det = self%det
        self%target%offset = self%offset
        self%target%lookup(:self%size) = self%lookup(:self%size)
        self%target => null()
    end

    ! -------------------------------------------------------------------------
    ! BLOCK MATRIX GROW

    pure function p_grow_isinit(self) result(test)
        type(ZBlockGrow), intent(in) :: self
        logical :: test

        test = allocated(self%block)
    end

    subroutine p_grow_init(self, nblocks)
        type(ZBlockGrow), intent(inout) :: self
        integer, intent(in) :: nblocks

        if (isinitialized(self)) return
        self%target => null()
        self%det = ZERO
        self%allowed = .false.
        allocate(self%active(nblocks))
        allocate(self%block(nblocks))
        allocate(self%offset(nblocks + 1))
        allocate(self%lookup(4))
        self%active(:) = .false.
        self%lookup(:) = -4711
        self%offset(:) = -4711
    end

    subroutine p_grow_setsize(self, newsize)
        type(ZBlockGrow), intent(inout) :: self
        integer, intent(in) :: newsize
        integer :: maxsize

        maxsize = size(self%lookup)
        if (newsize > maxsize) then
            deallocate(self%lookup)
            allocate(self%lookup(newsize + 1))
            self%lookup(:) = -4711
        endif
        self%size = newsize
    end

    subroutine p_grow_propose(self, t, iblock, jblock, inew, jnew, rows, cols, dot)
        type(ZBlockGrow), intent(inout) :: self
        type(ZBlockMatrix), intent(inout), target :: t
        integer, intent(in) :: iblock(:), jblock(:)
        integer, intent(in) :: inew(:), jnew(:)
        complex(c_double_complex), intent(in) :: rows(:, :), cols(:, :), dot(:, :)

        integer :: nblocks, rank, currsize
        integer :: i, b, icur, iend, bcur, bend

        ! TODO preallocate temp arrays
        integer :: iadd(t%nblocks+1)
        integer :: inew_bl(size(inew)), jnew_bl(size(jnew))

        nblocks = t%nblocks
        currsize = t%size
        rank = size(iblock)

        if (.not. isinitialized(t)) &
            error stop 'block matrix not initialized'
        if (size(inew) /= rank .or. size(jnew) /= rank) &
            error stop 'Invalid size of index array'
        if (size(iblock) /= rank .or. size(jblock) /= rank) &
            error stop 'Invalid block'
        if (size(rows,1) /= rank .or. size(rows,2) /= currsize) &
            error stop 'Invalid size of rows array'
        if (size(cols,1) /= currsize .or. size(cols,2) /= rank) &
            error stop 'Invalid size of columns array'
        if (size(dot,1) /= rank .or. size(dot,2) /= rank) &
            error stop 'Invalid size of dot array'

        call initialize(self, nblocks)
        call setsize(self, currsize + rank)
        self%target => t

        ! First, compute how much we are adding to each block.
        call p_compute_offsets(iblock, iadd)
        call p_compute_offsets(jblock, iadd)

        self%allowed = all(iblock == jblock)
        if (.not. self%allowed) then
            self%det = ZERO
            return
        endif

        ! Next, update the offsets and lookup, because the indices refer
        ! to the rows and columns in the "enlarged" block.
        self%offset(:) = self%target%offset(:) + iadd(:)
        call p_compute_lookup(self%offset, self%lookup)

        ! Next, translate the index in the global enlarged matrix to indices
        ! in the blocks.
        do i = 1, rank
            bcur = self%offset(iblock(i))
            bend = self%offset(iblock(i)+1)
            if (inew(i) <= bcur .or. inew(i) > bend) &
                error stop 'row index does not match its supposed block'
            if (jnew(i) <= bcur .or. jnew(i) > bend) &
                error stop 'column index does not match its supposed block'

            inew_bl(i) = inew(i) - bcur
            jnew_bl(i) = jnew(i) - bcur
        enddo

        ! Finally, generate the block moves
        do b = 1, nblocks
            ! Careful: the offsets in the addition vectors must refer to the
            ! unenlarged (target) matrix, because these are the "augmented"
            ! parts.
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)
            bcur = iadd(b)
            bend = iadd(b+1)
            self%active(b) = bcur /= bend

            if (.not. self%active(b)) &
                cycle

            call check_block(rows(:, icur+1:iend), bcur, bend)
            call check_block(cols(:, bcur+1:bend), icur, iend)
            call check_block(dot(:, bcur+1:bend), bcur, bend)

            call propose_grow_matrix( &
                    self%block(b), self%target%block(b), &
                    inew_bl(bcur+1:bend), jnew_bl(bcur+1:bend), &
                    rows(bcur+1:bend, icur+1:iend), &
                    cols(icur+1:iend, bcur+1:bend), &
                    dot(bcur+1:bend, bcur+1:bend))
        enddo

        ! Update the determinant
        self%det = ONE
        do b = 1, nblocks
            if (self%active(b)) then
                self%det = self%det * get_det(self%block(b))
            else
                self%det = self%det * get_det(self%target%block(b))
            endif
        enddo
    end

    subroutine p_grow_accept(self)
        class(ZBlockGrow), intent(inout) :: self
        integer :: b

        if (.not. associated(self%target)) &
            error stop 'No move proposed'
        if (.not. self%allowed) &
            error stop 'Cannot accept move which violates symmetry'

        do b = 1, self%target%nblocks
            if (self%active(b)) &
                call accept_update(self%block(b))
        end do

        call setsize(self%target, self%size)
        self%target%det = self%det
        self%target%offset = self%offset
        self%target%lookup(:self%size) = self%lookup(:self%size)
        self%target => null()
    end

    ! -------------------------------------------------------------------------
    ! BLOCK MATRIX SHRINK

    pure function p_shrink_isinit(self) result(test)
        type(ZBlockShrink), intent(in) :: self
        logical :: test

        test = allocated(self%block)
    end

    subroutine p_shrink_init(self, nblocks)
        type(ZBlockShrink), intent(inout) :: self
        integer, intent(in) :: nblocks

        if (isinitialized(self)) return
        self%target => null()
        self%det = ZERO
        self%allowed = .false.
        allocate(self%active(nblocks))
        allocate(self%block(nblocks))
        allocate(self%offset(nblocks + 1))
        allocate(self%lookup(4))
        self%active(:) = .false.
        self%lookup(:) = -4711
        self%offset(:) = -4711
    end

    subroutine p_shrink_setsize(self, newsize, rank)
        type(ZBlockShrink), intent(inout) :: self
        integer, intent(in) :: newsize, rank
        integer :: maxsize

        maxsize = size(self%lookup)
        if (newsize + rank > maxsize) then
            deallocate(self%lookup)
            allocate(self%lookup(newsize + rank + 1))
            self%lookup(:) = -4711
        endif
        self%size = newsize
        self%rank = rank
    end

    subroutine p_shrink_propose(self, t, irem, jrem)
        type(ZBlockShrink), intent(inout) :: self
        type(ZBlockMatrix), intent(inout), target :: t
        integer, intent(in) :: irem(:), jrem(:)

        integer :: nblocks, rank, currsize
        integer :: i, b, icur, iend, bcur, bend

        ! TODO preallocate temp arrays
        integer :: brem(t%nblocks+1)
        integer :: irem_sort(size(irem)), jrem_sort(size(jrem))

        nblocks = t%nblocks
        currsize = t%size
        rank = size(irem)

        if (.not. isinitialized(t)) &
            error stop 'block matrix not initialized'
        if (size(irem) /= rank .or. size(jrem) /= rank) &
            error stop 'Invalid size of index array'

        call initialize(self, nblocks)
        call setsize(self, currsize - rank, rank)
        self%target => t

        ! TODO: avoid temporaries here
        irem_sort = irem(get_sort_perm(irem))
        jrem_sort = jrem(get_sort_perm(jrem))
        call p_compute_offsets(self%target%lookup(irem_sort), brem)

        ! Ttranslate the index in the global enlarged matrix to indices
        ! in the blocks.
        do i = 1, rank
            if (irem_sort(i) < 1 .or. irem_sort(i) > currsize) &
                error stop 'Invalid row index'
            if (jrem_sort(i) < 1 .or. jrem_sort(i) > currsize) &
                error stop 'Invalid column index'

            b = self%target%lookup(irem_sort(i))
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)
            if (jrem_sort(i) <= icur .or. jrem_sort(i) > iend) then
                self%allowed = .false.
                self%det = ZERO
                return
            endif

            irem_sort(i) = irem_sort(i) - icur
            jrem_sort(i) = jrem_sort(i) - icur
        enddo

        self%allowed = .true.
        self%offset(:) = self%target%offset(:) - brem(:)
        call p_compute_lookup(self%offset, self%lookup)

        ! Finally, generate the block moves
        do b = 1, nblocks
            bcur = brem(b)
            bend = brem(b+1)
            self%active(b) = bcur /= bend

            if (.not. self%active(b)) &
                cycle

            call propose_shrink_matrix( &
                    self%block(b), self%target%block(b), &
                    irem_sort(bcur+1:bend), jrem_sort(bcur+1:bend))
        enddo

        ! Update the determinant
        self%det = ONE
        do b = 1, nblocks
            if (self%active(b)) then
                self%det = self%det * get_det(self%block(b))
            else
                self%det = self%det * get_det(self%target%block(b))
            endif
        enddo
    end

    subroutine p_shrink_accept(self)
        class(ZBlockShrink), intent(inout) :: self
        integer :: b

        if (.not. associated(self%target)) &
            error stop 'No move proposed'
        if (.not. self%allowed) &
            error stop 'Cannot accept move which violates symmetry'

        do b = 1, self%target%nblocks
            if (self%active(b)) &
                call accept_update(self%block(b))
        end do

        call setsize(self%target, self%size)
        self%target%det = self%det
        self%target%offset = self%offset
        self%target%lookup(:self%size) = self%lookup(:self%size)
        self%target => null()
    end

    ! -------------------------------------------------------------------------
    ! BLOCK MATRIX ROWS REPLACE

    pure function p_rows_isinit(self) result(test)
        type(ZBlockReplaceRows), intent(in) :: self
        logical :: test

        test = allocated(self%block)
    end

    subroutine p_rows_init(self, nblocks)
        type(ZBlockReplaceRows), intent(inout) :: self
        integer, intent(in) :: nblocks

        if (isinitialized(self)) return
        self%target => null()
        self%det = ZERO
        self%allowed = .false.
        allocate(self%active(nblocks))
        allocate(self%block(nblocks))
        self%active(:) = .false.
    end

    subroutine p_rows_setsize(self, newsize, rank)
        type(ZBlockReplaceRows), intent(inout) :: self
        integer, intent(in) :: newsize, rank

        self%size = newsize
        self%rank = rank
    end

    subroutine p_rows_propose(self, t, ifrom, ito, val)
        type(ZBlockReplaceRows), intent(inout) :: self
        type(ZBlockMatrix), intent(inout), target :: t
        integer, intent(in) :: ifrom(:), ito(:)
        complex(c_double_complex), intent(in) :: val(:, :)

        integer :: nblocks, rank, currsize
        integer :: i, b, icur, iend, bcur, bend

        ! TODO preallocate temp arrays
        integer :: brepl(t%nblocks+1)
        integer :: ifrom_sort(size(ifrom)), ito_sort(size(ito))
        integer :: perm(size(ifrom))
        complex(c_double_complex) :: val_sort(size(val,1), size(val,2))

        nblocks = t%nblocks
        currsize = t%size
        rank = size(ifrom)

        if (.not. isinitialized(t)) &
            error stop 'block matrix not initialized'
        if (size(ifrom) /= rank .or. size(ito) /= rank) &
            error stop 'Invalid size of index array'
        if (size(val,1) /= rank .or. size(val,2) /= currsize) &
            error stop 'Invalid size of values array'

        call initialize(self, nblocks)
        call setsize(self, currsize, rank)
        self%target => t

        ifrom_sort(:) = ifrom(:)
        call sort_perm(ifrom_sort, perm)
        ito_sort(:) = ito(perm)
        val_sort(:,:) = val(perm, :)
        call p_compute_offsets(self%target%lookup(ifrom_sort), brepl)

        do i = 1, rank
            if (ifrom_sort(i) < 1 .or. ifrom_sort(i) > currsize) &
                error stop 'Invalid row source index'
            if (ito_sort(i) < 1 .or. ito_sort(i) > currsize) &
                error stop 'Invalid row destination index'

            b = self%target%lookup(ifrom_sort(i))
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)
            if (ito_sort(i) <= icur .or. ito_sort(i) > iend) then
                ! row destination index does not match its block
                self%allowed = .false.
                self%det = ZERO
                return
            endif

            ifrom_sort(i) = ifrom_sort(i) - icur
            ito_sort(i) = ito_sort(i) - icur
        enddo
        self%allowed = .true.

        ! Finally, generate the block moves
        do b = 1, nblocks
            bcur = brepl(b)
            bend = brepl(b+1)
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)
            self%active(b) = bcur /= bend

            if (.not. self%active(b)) &
                cycle

            call check_block(val_sort(:, icur+1:iend), bcur, bend)

            call propose_replace_rows( &
                    self%block(b), self%target%block(b), &
                    ifrom_sort(bcur+1:bend), ito_sort(bcur+1:bend), &
                    val_sort(bcur+1:bend, icur+1:iend))
        enddo

        ! Update the determinant
        self%det = ONE
        do b = 1, nblocks
            if (self%active(b)) then
                self%det = self%det * get_det(self%block(b))
            else
                self%det = self%det * get_det(self%target%block(b))
            endif
        enddo
    end

    subroutine p_rows_accept(self)
        class(ZBlockReplaceRows), intent(inout) :: self
        integer :: b

        if (.not. associated(self%target)) &
            error stop 'No move proposed'
        if (.not. self%allowed) &
            error stop 'Cannot accept move which violates symmetry'

        do b = 1, self%target%nblocks
            if (self%active(b)) &
                call accept_update(self%block(b))
        end do

        self%target%det = self%det
        self%target => null()
    end

    ! -------------------------------------------------------------------------
    ! BLOCK MATRIX COLUMNS REPLACE

    pure function p_cols_isinit(self) result(test)
        type(ZBlockReplaceCols), intent(in) :: self
        logical :: test

        test = allocated(self%block)
    end

    subroutine p_cols_init(self, nblocks)
        type(ZBlockReplaceCols), intent(inout) :: self
        integer, intent(in) :: nblocks

        if (isinitialized(self)) return
        self%target => null()
        self%det = ZERO
        self%allowed = .false.
        allocate(self%active(nblocks))
        allocate(self%block(nblocks))
        self%active(:) = .false.
    end

    subroutine p_cols_setsize(self, newsize, rank)
        type(ZBlockReplaceCols), intent(inout) :: self
        integer, intent(in) :: newsize, rank

        self%size = newsize
        self%rank = rank
    end

    subroutine p_cols_propose(self, t, ifrom, ito, val)
        type(ZBlockReplaceCols), intent(inout) :: self
        type(ZBlockMatrix), intent(inout), target :: t
        integer, intent(in) :: ifrom(:), ito(:)
        complex(c_double_complex), intent(in) :: val(:, :)

        integer :: nblocks, rank, currsize
        integer :: i, b, icur, iend, bcur, bend

        ! TODO preallocate temp arrays
        integer :: brepl(t%nblocks+1)
        integer :: ifrom_sort(size(ifrom)), ito_sort(size(ito))
        integer :: perm(size(ifrom))
        complex(c_double_complex) :: val_sort(size(val,1), size(val,2))

        nblocks = t%nblocks
        currsize = t%size
        rank = size(ifrom)

        if (.not. isinitialized(t)) &
            error stop 'block matrix not initialized'
        if (size(ifrom) /= rank .or. size(ito) /= rank) &
            error stop 'Invalid size of index array'
        if (size(val,1) /= currsize .or. size(val,2) /= rank) &
            error stop 'Invalid size of values array'

        call initialize(self, nblocks)
        call setsize(self, currsize, rank)
        self%target => t

        ifrom_sort(:) = ifrom(:)
        call sort_perm(ifrom_sort, perm)
        ito_sort(:) = ito(perm)
        val_sort(:,:) = val(:,perm)
        call p_compute_offsets(self%target%lookup(ifrom_sort), brepl)

        do i = 1, rank
            if (ifrom_sort(i) < 1 .or. ifrom_sort(i) > currsize) &
                error stop 'Invalid row source index'
            if (ito_sort(i) < 1 .or. ito_sort(i) > currsize) &
                error stop 'Invalid row destination index'

            b = self%target%lookup(ifrom_sort(i))
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)
            if (ito_sort(i) <= icur .or. ito_sort(i) > iend) then
                ! col destination index does not match its block
                self%allowed = .false.
                self%det = ZERO
                return
            endif

            ifrom_sort(i) = ifrom_sort(i) - icur
            ito_sort(i) = ito_sort(i) - icur
        enddo
        self%allowed = .true.

        ! Finally, generate the block moves
        do b = 1, nblocks
            bcur = brepl(b)
            bend = brepl(b+1)
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)
            self%active(b) = bcur /= bend

            if (.not. self%active(b)) &
                cycle

            call check_block(val_sort(:, bcur+1:bend), icur, iend)

            call propose_replace_cols( &
                    self%block(b), self%target%block(b), &
                    ifrom_sort(bcur+1:bend), ito_sort(bcur+1:bend), &
                    val_sort(icur+1:iend, bcur+1:bend))
        enddo

        ! Update the determinant
        self%det = ONE
        do b = 1, nblocks
            if (self%active(b)) then
                self%det = self%det * get_det(self%block(b))
            else
                self%det = self%det * get_det(self%target%block(b))
            endif
        enddo
    end

    subroutine p_cols_accept(self)
        class(ZBlockReplaceCols), intent(inout) :: self
        integer :: b

        if (.not. associated(self%target)) &
            error stop 'No move proposed'
        if (.not. self%allowed) &
            error stop 'Cannot accept move which violates symmetry'

        do b = 1, self%target%nblocks
            if (self%active(b)) &
                call accept_update(self%block(b))
        end do

        self%target%det = self%det
        self%target => null()
    end

    ! -------------------------------------------------------------------------
    ! BLOCK MATRIX PERMUTATAION

    pure function p_permute_isinit(self) result(test)
        type(ZBlockPermute), intent(in) :: self
        logical :: test

        test = allocated(self%block)
    end

    subroutine p_permute_init(self, nblocks)
        type(ZBlockPermute), intent(inout) :: self
        integer, intent(in) :: nblocks

        if (isinitialized(self)) return
        self%target => null()
        self%allowed = .false.
        self%det = ZERO
        allocate(self%active(nblocks))
        allocate(self%block(nblocks))
        self%active(:) = .false.
    end

    subroutine p_permute_setsize(self, newsize)
        type(ZBlockPermute), intent(inout) :: self
        integer, intent(in) :: newsize

        self%size = newsize
    end

    subroutine p_permute_propose(self, t, iperm, jperm, iscale, jscale)
        type(ZBlockPermute), intent(inout) :: self
        type(ZBlockMatrix), intent(inout), target :: t
        integer, intent(in) :: iperm(:), jperm(:)
        complex(c_double_complex), intent(in) :: iscale(:), jscale(:)

        integer :: nblocks, currsize
        integer :: i, b, icur, iend

        ! TODO preallocate temp arrays
        integer :: iperm_bl(size(iperm)), jperm_bl(size(jperm))

        nblocks = t%nblocks
        currsize = t%size

        if (.not. isinitialized(t)) &
            error stop 'block matrix not initialized'
        if (size(iperm) /= currsize .or. size(jperm) /= currsize) &
            error stop 'Invalid size of permutation array'
        if (size(iscale) /= currsize .or. size(jscale) /= currsize) &
            error stop 'Invalid size of scale array'

        call initialize(self, nblocks)
        call setsize(self, currsize)
        self%target => t

        do i = 1, currsize
            b = self%target%lookup(i)
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)

            if (iperm(i) <= icur .or. iperm(i) > iend &
                    .or. jperm(i) <= icur .or. jperm(i) > iend) then
                self%allowed = .false.
                self%det = ZERO
                return
            endif

            ! The validity of the permutation is checked later.
            iperm_bl(i) = iperm(i) - icur
            jperm_bl(i) = jperm(i) - icur
        enddo
        self%allowed = .true.

        ! Finally, generate the block moves
        do b = 1, nblocks
            icur = self%target%offset(b)
            iend = self%target%offset(b+1)
            self%active(b) = .true.

            call propose_permute_matrix( &
                    self%block(b), self%target%block(b), &
                    iperm_bl(icur+1:iend), jperm_bl(icur+1:iend), &
                    iscale(icur+1:iend), jscale(icur+1:iend))
        enddo

        ! Update the determinant
        self%det = ONE
        do b = 1, nblocks
            if (self%active(b)) then
                self%det = self%det * get_det(self%block(b))
            else
                self%det = self%det * get_det(self%target%block(b))
            endif
        enddo
    end

    subroutine p_permute_accept(self)
        class(ZBlockPermute), intent(inout) :: self
        integer :: b

        if (.not. associated(self%target)) &
            error stop 'No move proposed'

        do b = 1, self%target%nblocks
            if (self%active(b)) &
                call accept_update(self%block(b))
        end do

        self%target%det = self%det
        self%target => null()
    end

end module
