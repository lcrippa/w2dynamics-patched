! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.

module MSamplerD
    use iso_c_binding, only: c_int, c_int64_t, c_double, c_double_complex, c_null_ptr
    use MFFTW
    implicit none
    private

    !> A sampling point, i.e., a tuple (i, x, f(x))
    type, public :: DSamplePoint
        integer(c_int64_t) :: i
        real(c_double) :: x
        real(c_double) :: fx
    end type

    !> A buffer for the use of sampling points
    type, public :: DSampleBuffer
        type(DSamplePoint), allocatable :: buffer(:)
        integer :: n
    end type

    !> A sampling point, i.e., a tuple (i, x, f(x))
    type, public :: DSamplePoint2D
        integer(c_int64_t) :: i
        real(c_double) :: x(2)
        real(c_double) :: fx
    end type DSamplePoint2D

    !> A buffer for the use of sampling points
    type, public :: DSampleBuffer2D
        type(DSamplePoint2D), allocatable :: buffer(:)
        integer :: n
    end type DSampleBuffer2D

    !> A sampling point, i.e., a tuple (i, x, f(x))
    type, public :: DSamplePoint3D
        integer(c_int64_t) :: i
        real(c_double) :: x(3)
        real(c_double) :: fx
    end type DSamplePoint3D

    !> A buffer for the use of sampling points
    type, public :: DSampleBuffer3D
        type(DSamplePoint3D), allocatable :: buffer(:)
        integer :: n
    end type DSampleBuffer3D

    !> Transformer of a sampled function into a discretized form
    !!
    !! Let $f(\tau)$ be some vector-valued function of imaginary time $\tau$.
    !! Say we sample that function, i.e., we have a set of sampling points
    !! consisting of time $\tau_n$, component index $i_n$ and a corresponding
    !! value $f_n = f_{i_n}(\tau_n)`. We write this sampled form:
    !! as:
    !! $$
    !!      \hat f_i(\tau) = \frac 1{\beta}
    !!              \sum_n f_n \delta(\tau - \tau_n) \delta_{ii_n}
    !! $$
    !!
    !! A sampler now takes the set of these delta-like points and maps them
    !! onto a suitable discretization the function, either:
    !!
    !!   - a histogram (see `init_binning_sampler`)
    !!   - a polynomial basis (see `init_legendre_sampler`)
    !!   - Matsubara frequencies (see `init_fast_matsubara_sampler`)
    !!
    type, public :: DSampler
        integer :: ncomp, nacc, npost
        real(c_double) :: beta, coeff
        integer :: statsign
    contains
        private
        procedure :: add_d => null_add_d
        procedure :: add_z => null_add_z
        procedure :: postprocess_d => null_postprocess_d
        procedure :: postprocess_z => null_postprocess_z
        procedure :: delete => null_delete
    end type

    type, public :: DSampler2D
        integer :: ncomp, nacc, npost
        real(c_double) :: beta, coeffs(2, 2)
        integer :: statsign(2)
    contains
        private
        procedure :: add_d => null2d_add_d
        procedure :: add_z => null2d_add_z
        procedure :: postprocess_d => null2d_postprocess_d
        procedure :: postprocess_z => null2d_postprocess_z
        procedure :: delete => null2d_delete
    end type DSampler2D

    type, public :: DSampler3D
        integer :: ncomp, nacc, npost
        real(c_double) :: beta, coeffs(3, 3)
        integer :: statsign(3)
    contains
        private
        procedure :: add_d => null3d_add_d
        procedure :: add_z => null3d_add_z
        procedure :: postprocess_d => null3d_postprocess_d
        procedure :: postprocess_z => null3d_postprocess_z
        procedure :: delete => null3d_delete
    end type DSampler3D

    ! Sampler which just bins the data.
    type, private, extends(DSampler) :: binning_sampler
        integer :: nbins
    contains
        procedure, non_overridable :: add_d => rhist_add
        procedure, non_overridable :: postprocess_d => rhist_postprocess
    end type

    ! Sampler which just bins the data.
    type, private, extends(DSampler2D) :: binning_sampler2d
        integer :: nbins(2)
    contains
        procedure, non_overridable :: add_d => rhist2d_add
        procedure, non_overridable :: postprocess_d => rhist2d_postprocess
    end type binning_sampler2d

    ! Sampler which just bins the data.
    type, private, extends(DSampler3D) :: binning_sampler3d
        integer :: nbins(3)
    contains
        procedure, non_overridable :: add_d => rhist3d_add
        procedure, non_overridable :: postprocess_d => rhist3d_postprocess
    end type binning_sampler3d

    ! Sampler which performs naive Fourier transform
    type, private, extends(DSampler) :: matsubara_sampler
        integer, allocatable :: w(:)
    contains
        procedure, non_overridable :: add_z => nfourier_add
        procedure, non_overridable :: postprocess_z => nfourier_postprocess
    end type

    ! Sampler which performs naive Fourier transform in 2D
    type, private, extends(DSampler2D) :: matsubara_sampler_2d
        integer, allocatable :: w1(:), w2(:)
    contains
        procedure :: add_z => nfourier2d_add
        procedure :: postprocess_z => nfourier2d_postprocess
    end type

    ! Sampler which performs sampling in Legendre
    type, private, extends(DSampler) :: legendre_sampler
        integer :: nleg
    contains
        procedure, non_overridable :: add_d => legendre_add
        procedure, non_overridable :: postprocess_d => legendre_postprocess
    end type

    ! Gaussian window for use in NFFT
    type :: gauss_window
        ! m: localization scale of the kernel (number of support
        !    points beyond which it is cut off)
        ! nfreq: number of resulting frequencies
        ! ngrid: number of tau points in the full grid
        integer :: m, nfreq, ngrid
        ! normalization coefficients (norm) and exponent prefactors
        ! (exp) in tau (t) and frequency (k) domain
        real(c_double) :: tnorm, texp, knorm, kexp
        ! precomputed values of the first factor of the window
        ! function
        real(c_double), allocatable :: lfact(:)
    end type

    !> Sampler which performs fast Fourier transform
    type, extends(DSampler) :: nfft_sampler
        ! result frequencies
        integer, allocatable :: w(:)
        ! number of grid points plus m (half of the number of support
        ! points beyond which the window function is truncated)
        ! additional points at each edge to catch window contributions
        ! from tau points near the edge
        integer :: nextgrid
        type(gauss_window) :: window

        type(c_ptr) :: fft_plan
        complex(c_double_complex), allocatable :: fft_in(:,:)
        complex(c_double_complex), allocatable :: fft_out(:,:)
    contains
        procedure, non_overridable :: add_z => nfft_add
        procedure, non_overridable :: postprocess_z => nfft_postprocess
        procedure, non_overridable :: delete => nfft_delete
    end type

    !> Sampler which performs fast Fourier transform, two dimensions
    type, extends(DSampler2D) :: nfft_sampler2d
        integer, allocatable :: w1(:), w2(:)
        integer :: nextgrid(2)
        type(gauss_window) :: window(2)

        type(c_ptr) :: fft_plan
        complex(c_double_complex), allocatable :: fft_in(:, :, :)
        complex(c_double_complex), allocatable :: fft_out(:, :, :)
    contains
        procedure, non_overridable :: add_z => nfft2d_add
        procedure, non_overridable :: postprocess_z => nfft2d_postprocess
        procedure, non_overridable :: delete => nfft2d_delete
    end type nfft_sampler2d

    !> Sampler which performs fast Fourier transform, three dimensions
    type, extends(DSampler3D) :: nfft_sampler3d
        integer, allocatable :: w1(:), w2(:), w3(:)
        integer :: nextgrid(3)
        type(gauss_window) :: window(3)

        type(c_ptr) :: fft_plan
        complex(c_double_complex), allocatable :: fft_in(:, :, :, :)
        complex(c_double_complex), allocatable :: fft_out(:, :, :, :)
    contains
        procedure, non_overridable :: add_z => nfft3d_add
        procedure, non_overridable :: postprocess_z => nfft3d_postprocess
        procedure, non_overridable :: delete => nfft3d_delete
    end type nfft_sampler3d

    interface prepare_buffer
       module procedure p_prepare_buffer, p_prepare_buffer2d, p_prepare_buffer3d
    end interface
    public prepare_buffer

    interface init_binning_sampler
       module procedure rhist_init, rhist2d_init, rhist3d_init
    end interface
    public init_binning_sampler

    interface init_legendre_sampler
       module procedure legendre_init
    end interface
    public init_legendre_sampler

    interface init_matsubara_sampler
       module procedure nfourier_init, nfourier2d_init
    end interface
    public init_matsubara_sampler

    interface init_fast_matsubara_sampler
        module procedure nfft_init, nfft2d_init, nfft3d_init
    end interface
    public init_fast_matsubara_sampler

    interface sampler_add
        module procedure p_sampler_add_z, p_sampler_add_d
        module procedure p_sampler2d_add_z, p_sampler2d_add_d
        module procedure p_sampler3d_add_z, p_sampler3d_add_d
    end interface
    public sampler_add

    interface sampler_postprocess
       module procedure p_sampler_postprocess_z, p_sampler_postprocess_d
       module procedure p_sampler2d_postprocess_z, p_sampler2d_postprocess_d
       module procedure p_sampler3d_postprocess_z, p_sampler3d_postprocess_d
    end interface
    public sampler_postprocess

    interface sampler_delete
       module procedure p_sampler_delete, p_sampler2d_delete, p_sampler3d_delete
    end interface
    public sampler_delete

    logical, parameter :: value_is_complex = .false.

    real(c_double), parameter :: PI = acos(-1.0D0)

contains

    ! --- AUXILIARY ROUTINES

    pure subroutine p_prepare_buffer(this, n)
        type(DSampleBuffer), intent(inout) :: this
        integer, intent(in) :: n

        if (.not. allocated(this%buffer)) then
            allocate(this%buffer(n))
        else if (n > this%n) then
            deallocate(this%buffer)
            allocate(this%buffer(n))
        end if
        this%n = n
    end subroutine

    pure subroutine p_prepare_buffer2d(this, n)
        type(DSampleBuffer2D), intent(inout) :: this
        integer, intent(in) :: n

        if (.not. allocated(this%buffer)) then
            allocate(this%buffer(n))
        else if (n > this%n) then
            deallocate(this%buffer)
            allocate(this%buffer(n))
        end if
        this%n = n
    end subroutine p_prepare_buffer2d

    pure subroutine p_prepare_buffer3d(this, n)
        type(DSampleBuffer3D), intent(inout) :: this
        integer, intent(in) :: n

        if (.not. allocated(this%buffer)) then
            allocate(this%buffer(n))
        else if (n > this%n) then
            deallocate(this%buffer)
            allocate(this%buffer(n))
        end if
        this%n = n
    end subroutine p_prepare_buffer3d

    pure function sample_wraptau(this, sample) result(res)
        class(DSampler), intent(in) :: this
        type(DSamplePoint), intent(in) :: sample
        type(DSamplePoint) :: res

        res = sample
        if (sample%x < 0) then
            res%x = res%x + this%beta
            res%fx = this%statsign * res%fx
        end if
    end function

    pure function sample_2d_wraptau(this, sample) result(res)
        class(DSampler2D), intent(in) :: this
        type(DSamplePoint2D), intent(in) :: sample
        type(DSamplePoint2D) :: res
        integer :: i

        res = sample
        do i = 1, size(sample%x)
            if (sample%x(i) < 0) then
                res%x(i) = res%x(i) + this%beta
                res%fx = this%statsign(i) * res%fx
             end if
        end do
    end function sample_2d_wraptau

    pure function sample_3d_wraptau(this, sample) result(res)
        class(DSampler3D), intent(in) :: this
        type(DSamplePoint3D), intent(in) :: sample
        type(DSamplePoint3D) :: res
        integer :: i

        res = sample
        do i = 1, size(sample%x)
            if (sample%x(i) < 0) then
                res%x(i) = res%x(i) + this%beta
                res%fx = this%statsign(i) * res%fx
             end if
        end do
    end function sample_3d_wraptau

    ! --- DSampler

    subroutine p_sampler_add_d(this, sample, acc)
        class(DSampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        real(c_double), intent(inout) :: acc(this%nacc, this%ncomp)
        type(DSamplePoint) :: convention_sample(size(sample))

        convention_sample = sample
        convention_sample%x = this%coeff * convention_sample%x
        call this%add_d(convention_sample, acc)
    end subroutine

    subroutine p_sampler_add_z(this, sample, acc)
        class(DSampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout) :: acc(this%nacc, this%ncomp)
        type(DSamplePoint) :: convention_sample(size(sample))

        convention_sample = sample
        convention_sample%x = this%coeff * convention_sample%x
        call this%add_z(convention_sample, acc)
    end subroutine

    subroutine p_sampler_postprocess_d(this, acc, res)
        class(DSampler), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        call this%postprocess_d(acc, res)
    end subroutine

    subroutine p_sampler_postprocess_z(this, acc, res)
        class(DSampler), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        call this%postprocess_z(acc, res)
    end subroutine

    subroutine p_sampler_delete(this)
        class(DSampler), allocatable, intent(inout) :: this

        call this%delete()
        deallocate(this)
    end subroutine

    subroutine p_sampler2d_add_d(this, sample, acc)
        class(DSampler2D), intent(inout) :: this
        type(DSamplePoint2D), intent(in) :: sample(:)
        real(c_double), intent(inout), target :: acc(this%nacc, this%ncomp)
        type(DSamplePoint2D) :: convention_sample(size(sample))
        integer :: i

        convention_sample = sample
        do i = 1, size(sample)
           convention_sample(i)%x = matmul(this%coeffs, sample(i)%x)
        end do
        call this%add_d(convention_sample, acc)
    end subroutine p_sampler2d_add_d

    subroutine p_sampler2d_add_z(this, sample, acc)
        class(DSampler2D), intent(inout) :: this
        type(DSamplePoint2D), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout), target :: acc(this%nacc, this%ncomp)
        type(DSamplePoint2D) :: convention_sample(size(sample))
        integer :: i

        convention_sample = sample
        do i = 1, size(sample)
           convention_sample(i)%x = matmul(this%coeffs, sample(i)%x)
        end do
        call this%add_z(convention_sample, acc)
    end subroutine p_sampler2d_add_z

    subroutine p_sampler2d_postprocess_d(this, acc, res)
        class(DSampler2D), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        call this%postprocess_d(acc, res)
    end subroutine p_sampler2d_postprocess_d

    subroutine p_sampler2d_postprocess_z(this, acc, res)
        class(DSampler2D), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        call this%postprocess_z(acc, res)
    end subroutine p_sampler2d_postprocess_z

    subroutine p_sampler2d_delete(this)
        class(DSampler2D), allocatable, intent(inout) :: this

        call this%delete()
        deallocate(this)
    end subroutine p_sampler2d_delete

    subroutine p_sampler3d_add_d(this, sample, acc)
        class(DSampler3D), intent(inout) :: this
        type(DSamplePoint3D), intent(in) :: sample(:)
        real(c_double), intent(inout), target :: acc(this%nacc, this%ncomp)
        type(DSamplePoint3D) :: convention_sample(size(sample))
        integer :: i

        convention_sample = sample
        do i = 1, size(sample)
           convention_sample(i)%x = matmul(this%coeffs, sample(i)%x)
        end do
        call this%add_d(convention_sample, acc)
    end subroutine p_sampler3d_add_d

    subroutine p_sampler3d_add_z(this, sample, acc)
        class(DSampler3D), intent(inout) :: this
        type(DSamplePoint3D), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout), target :: acc(this%nacc, this%ncomp)
        type(DSamplePoint3D) :: convention_sample(size(sample))
        integer :: i

        convention_sample = sample
        do i = 1, size(sample)
           convention_sample(i)%x = matmul(this%coeffs, sample(i)%x)
        end do
        call this%add_z(convention_sample, acc)
    end subroutine p_sampler3d_add_z

    subroutine p_sampler3d_postprocess_d(this, acc, res)
        class(DSampler3D), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        call this%postprocess_d(acc, res)
    end subroutine p_sampler3d_postprocess_d

    subroutine p_sampler3d_postprocess_z(this, acc, res)
        class(DSampler3D), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        call this%postprocess_z(acc, res)
    end subroutine p_sampler3d_postprocess_z

    subroutine p_sampler3d_delete(this)
        class(DSampler3D), allocatable, intent(inout) :: this

        call this%delete()
        deallocate(this)
    end subroutine p_sampler3d_delete

    ! --- DSampler ROUTINES

    subroutine sampler_init(this, ncomp, nacc, npost, beta, statsign, coeff)
        class(DSampler), intent(inout) :: this
        integer, intent(in) :: ncomp, nacc, npost, statsign
        real(c_double), intent(in) :: beta, coeff

        if (ncomp < 0) &
            stop 'number of components must be non-negative'
        if (nacc < 0) &
            stop 'number of accumulator elements must be non-negative'
        if (npost < 0) &
            stop 'number of postprocessing elements must be non-negative'
        if (beta <= 0) &
            stop 'beta must be postive'
        if (abs(statsign) /= 1) &
            stop 'sign must be +1 for bosons and -1 for fermions'

        this%ncomp = ncomp
        this%nacc = nacc
        this%npost = npost
        this%beta = beta
        this%statsign = statsign
        this%coeff = coeff
    end subroutine

    subroutine sampler2d_init(this, ncomp, nacc, npost, beta, statsign, coeffs)
        class(DSampler2D), intent(inout) :: this
        integer, intent(in) :: ncomp, nacc, npost, statsign(2)
        real(c_double), intent(in) :: beta, coeffs(2, 2)

        if (ncomp < 0) &
            stop 'number of components must be non-negative'
        if (nacc < 0) &
            stop 'number of accumulator elements must be non-negative'
        if (npost < 0) &
            stop 'number of postprocessing elements must be non-negative'
        if (beta <= 0) &
            stop 'beta must be postive'
        if (any(abs(statsign) /= 1)) &
            stop 'sign must be +1 for bosons and -1 for fermions'

        this%ncomp = ncomp
        this%nacc = nacc
        this%npost = npost
        this%beta = beta
        this%statsign = statsign
        this%coeffs = coeffs
    end subroutine sampler2d_init

    subroutine sampler3d_init(this, ncomp, nacc, npost, beta, statsign, coeffs)
        class(DSampler3D), intent(inout) :: this
        integer, intent(in) :: ncomp, nacc, npost, statsign(3)
        real(c_double), intent(in) :: beta, coeffs(3, 3)

        if (ncomp < 0) &
            stop 'number of components must be non-negative'
        if (nacc < 0) &
            stop 'number of accumulator elements must be non-negative'
        if (npost < 0) &
            stop 'number of postprocessing elements must be non-negative'
        if (beta <= 0) &
            stop 'beta must be postive'
        if (any(abs(statsign) /= 1)) &
            stop 'sign must be +1 for bosons and -1 for fermions'

        this%ncomp = ncomp
        this%nacc = nacc
        this%npost = npost
        this%beta = beta
        this%statsign = statsign
        this%coeffs = coeffs
      end subroutine sampler3d_init

    subroutine null_add_d(this, sample, acc)
        class(DSampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        real(c_double), intent(inout) :: acc(this%nacc, this%ncomp)

        error stop '[sampler_add] real type unsupported'
    end subroutine

    subroutine null_add_z(this, sample, acc)
        class(DSampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout) :: acc(this%nacc, this%ncomp)

        error stop '[sampler_add] complex type unsupported'
    end subroutine

    subroutine null_postprocess_d(this, acc, res)
        class(DSampler), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        error stop '[sampler_postprocess] real type unsupported'
    end subroutine

    subroutine null_postprocess_z(this, acc, res)
        class(DSampler), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        error stop '[sampler_postprocess] complex type unsupported'
    end subroutine

    subroutine null_delete(this)
        class(DSampler), intent(inout) :: this
    end subroutine

    subroutine null2d_add_d(this, sample, acc)
        class(DSampler2D), intent(inout) :: this
        type(DSamplePoint2D), intent(in) :: sample(:)
        real(c_double), intent(inout), target :: acc(this%nacc, this%ncomp)

        error stop '[sampler_add] real type unsupported'
    end subroutine null2d_add_d

    subroutine null2d_add_z(this, sample, acc)
        class(DSampler2D), intent(inout) :: this
        type(DSamplePoint2D), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout), target :: acc(this%nacc, this%ncomp)

        error stop '[sampler_add] complex type unsupported'
    end subroutine null2d_add_z

    subroutine null2d_postprocess_d(this, acc, res)
        class(DSampler2D), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        error stop '[sampler_postprocess] real type unsupported'
    end subroutine null2d_postprocess_d

    subroutine null2d_postprocess_z(this, acc, res)
        class(DSampler2D), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        error stop '[sampler_postprocess] complex type unsupported'
    end subroutine null2d_postprocess_z

    subroutine null2d_delete(this)
        class(DSampler2D), intent(inout) :: this
    end subroutine null2d_delete

    subroutine null3d_add_d(this, sample, acc)
        class(DSampler3D), intent(inout) :: this
        type(DSamplePoint3D), intent(in) :: sample(:)
        real(c_double), intent(inout), target :: acc(this%nacc, this%ncomp)

        error stop '[sampler_add] real type unsupported'
    end subroutine null3d_add_d

    subroutine null3d_add_z(this, sample, acc)
        class(DSampler3D), intent(inout) :: this
        type(DSamplePoint3D), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout), target :: acc(this%nacc, this%ncomp)

        error stop '[sampler_add] complex type unsupported'
    end subroutine null3d_add_z

    subroutine null3d_postprocess_d(this, acc, res)
        class(DSampler3D), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        error stop '[sampler_postprocess] real type unsupported'
    end subroutine null3d_postprocess_d

    subroutine null3d_postprocess_z(this, acc, res)
        class(DSampler3D), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        error stop '[sampler_postprocess] complex type unsupported'
    end subroutine null3d_postprocess_z

    subroutine null3d_delete(this)
        class(DSampler3D), intent(inout) :: this
    end subroutine null3d_delete

    ! --- HISTOGRAM ROUTINES

    subroutine rhist_init(this_s, ncomp, beta, statsign, nbins, coeff)
        class(DSampler), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign, nbins
        real(c_double), intent(in) :: beta, coeff

        type(binning_sampler), allocatable :: this

        allocate(this)
        call sampler_init(this, ncomp, nbins, nbins, beta, statsign, coeff)
        this%nbins = nbins

        call move_alloc(this, this_s)
    end subroutine

    subroutine rhist_add(this, sample, acc)
        class(binning_sampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        real(c_double), intent(inout) :: acc(0:this%nacc-1, this%ncomp)

        real(c_double) :: invd
        integer(c_int64_t) :: i, bin
        type(DSamplePoint) :: curr

        ! FP multiplication is faster than division
        invd = this%nbins / this%beta
        do i = 1, size(sample)
            curr = sample_wraptau(this, sample(i))
            bin = int(invd * curr%x)
            acc(bin, curr%i) = acc(bin, curr%i) + curr%fx
        end do
    end subroutine

    subroutine rhist_postprocess(this, acc, res)
        class(binning_sampler), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        ! divide by:
        !  1. length of tau slice to get "average"
        !  2. another factor beta for mapping of two time arguments to one
        res(:,:) = acc(:,:) * (this%nbins / this%beta**2)
    end subroutine

    subroutine rhist2d_init(this_s, ncomp, beta, statsign, nbins, coeffs)
        class(DSampler2D), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign(2), nbins(2)
        real(c_double), intent(in) :: beta, coeffs(2, 2)

        type(binning_sampler2d), allocatable :: this

        allocate(this)
        call sampler2d_init(this, ncomp, product(nbins), product(nbins), &
                            beta, statsign, coeffs)
        this%nbins = nbins

        call move_alloc(this, this_s)
    end subroutine rhist2d_init

    subroutine rhist2d_add(this, sample, acc)
        class(binning_sampler2d), intent(inout) :: this
        type(DSamplePoint2D), intent(in) :: sample(:)
        real(c_double), intent(inout), target :: acc(0:this%nacc-1, this%ncomp)
        real(c_double), pointer :: buf(:, :, :)

        real(c_double) :: invd(2)
        integer(c_int64_t) :: i, bin(2)
        type(DSamplePoint2D) :: curr

        buf(0:this%nbins(1)-1, 0:this%nbins(2)-1, 1:this%ncomp) => acc

        ! FP multiplication is faster than division
        invd = this%nbins / this%beta
        do i = 1, size(sample)
            curr = sample_2d_wraptau(this, sample(i))
            bin = int(invd * curr%x)
            buf(bin(1), bin(2), curr%i) =&
                 buf(bin(1), bin(2), curr%i) + curr%fx
        end do
    end subroutine rhist2d_add

    subroutine rhist2d_postprocess(this, acc, res)
        class(binning_sampler2d), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        ! divide by:
        !  1. length of tau slice to get "average"
        !  2. another factor beta for mapping to one fewer time argument
        res(:, :) = acc(:, :) * (product(this%nbins) / this%beta**2)
    end subroutine rhist2d_postprocess

    subroutine rhist3d_init(this_s, ncomp, beta, statsign, nbins, coeffs)
        class(DSampler3D), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign(3), nbins(3)
        real(c_double), intent(in) :: beta, coeffs(3, 3)

        type(binning_sampler3d), allocatable :: this

        allocate(this)
        call sampler3d_init(this, ncomp, product(nbins), product(nbins), &
                            beta, statsign, coeffs)
        this%nbins = nbins

        call move_alloc(this, this_s)
    end subroutine rhist3d_init

    subroutine rhist3d_add(this, sample, acc)
        class(binning_sampler3d), intent(inout) :: this
        type(DSamplePoint3D), intent(in) :: sample(:)
        real(c_double), intent(inout), target :: acc(0:this%nacc-1, this%ncomp)
        real(c_double), pointer :: buf(:, :, :, :)

        real(c_double) :: invd(3)
        integer(c_int64_t) :: i, bin(3)
        type(DSamplePoint3D) :: curr

        buf(0:this%nbins(1)-1, 0:this%nbins(2)-1, 0:this%nbins(3)-1, 1:this%ncomp) => acc

        ! FP multiplication is faster than division
        invd = this%nbins / this%beta
        do i = 1, size(sample)
            curr = sample_3d_wraptau(this, sample(i))
            bin = int(invd * curr%x)
            buf(bin(1), bin(2), bin(3), curr%i) =&
                 buf(bin(1), bin(2), bin(3), curr%i) + curr%fx
        end do
    end subroutine rhist3d_add

    subroutine rhist3d_postprocess(this, acc, res)
        class(binning_sampler3d), intent(inout) :: this
        real(c_double), intent(in), target :: acc(this%nacc, this%ncomp)
        real(c_double), intent(out), target :: res(this%npost, this%ncomp)

        ! divide by:
        !  1. length of tau slice to get "average"
        !  2. another factor beta for mapping to one fewer time argument
        res(:, :) = acc(:, :) * (product(this%nbins) / this%beta**2)
    end subroutine rhist3d_postprocess

    ! --- NAIVE FOURIER ROUTINES

    subroutine nfourier_init(this_s, ncomp, beta, statsign, niw, sparse_frequencies, coeff, use_sparse)
        class(DSampler), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign, niw
        real(c_double), intent(in) :: beta, coeff
        integer, intent(in) :: sparse_frequencies(niw)
        logical, intent(in) :: use_sparse

        type(matsubara_sampler), allocatable :: this

        allocate(this)
        !allocate(this%w, source=default_frequencies(niw, statsign))
        if (use_sparse) then
            allocate(this%w, source=sparse_frequencies)
        else
            allocate(this%w, source=default_frequencies(niw, statsign))
        end if

        call sampler_init(this, ncomp, size(this%w), size(this%w), &
                          beta, statsign, coeff)
        call move_alloc(this, this_s)
    end subroutine

    function default_frequencies(niw, statsign) result(w)
        integer, intent(in) :: niw, statsign
        integer, allocatable :: w(:)
        integer :: i, zeta, wmax, wcurr

        if (niw < 0) &
            error stop 'Invalid number of frequencies'
        if (statsign /= 1 .and. statsign /= -1) &
            error stop 'Invalid statistics'

        ! Example niw=3
        !   bosonic:    -4, -2, 0, 2, 4      (statsign=+1, zeta=0)
        !   fermionic:  -5, -3, -1, 1, 3, 5  (statsign=-1, zeta=1)
        zeta = (1 - statsign) / 2
        wmax = 2 * (niw - 1) + zeta
        allocate(w(wmax + 1))

        wcurr = -wmax
        do i = 1, size(w)
            w(i) = wcurr
            wcurr = wcurr + 2
        enddo
    end function

    subroutine nfourier_add(this, sample, acc)
        class(matsubara_sampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout) :: acc(this%nacc, this%ncomp)

        integer(c_int64_t) :: i, n
        complex(c_double_complex) :: val, expfact

        ! Do naive Fourier transform. This scales as O(N**2)
        do i = 1, size(sample)
            do n = 1, size(this%w)
                expfact = cmplx( &
                            cos(PI/this%beta * sample(i)%x * this%w(n)), &
                            sin(PI/this%beta * sample(i)%x * this%w(n)), &
                            c_double_complex)
                val = expfact * sample(i)%fx
                acc(n, sample(i)%i) = acc(n, sample(i)%i) + val
            enddo
        enddo
    end subroutine

    subroutine nfourier_postprocess(this, acc, res)
        class(matsubara_sampler), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        ! divide by beta for mapping of two time arguments to one
        res(:,:) = acc(:,:) / this%beta
    end subroutine

    subroutine nfourier2d_init(this_s, ncomp, beta, statsign, niw, coeff)
        class(DSampler2D), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign(2), niw(2)
        real(c_double), intent(in) :: beta, coeff(2,2)

        type(matsubara_sampler_2d), allocatable :: this

        allocate(this)
        allocate(this%w1, source=default_frequencies(niw(1), statsign(1)))
        allocate(this%w2, source=default_frequencies(niw(2), statsign(2)))

        call sampler2d_init(this, ncomp, size(this%w1)*size(this%w2), size(this%w1)*size(this%w2), &
                          beta, statsign, coeff)
        call move_alloc(this, this_s)
    end subroutine

    subroutine nfourier2d_add(this, sample, acc)
        class(matsubara_sampler_2d), intent(inout) :: this
        type(DSamplePoint2D), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), pointer :: buf(:, :, :)

        integer(c_int64_t) :: i, n1, n2
        complex(c_double_complex) :: val, expfact1, expfact2

        buf(1:size(this%w1), 1:size(this%w2), 1:this%ncomp) => acc !(1:this%nacc, 1:this%ncomp)

        ! Do naive Fourier transform. This scales as O(N**2)
        do i = 1, size(sample)
            do n1 = 1, size(this%w1)
                do n2 = 1, size(this%w2)
                    expfact1 = cmplx( &
                                cos(PI/this%beta * sample(i)%x(1) * this%w1(n1)), &
                                sin(PI/this%beta * sample(i)%x(1) * this%w1(n1)), &
                                c_double_complex)
                    expfact2 = cmplx( &
                                cos(PI/this%beta * sample(i)%x(2) * this%w2(n2)), &
                                sin(PI/this%beta * sample(i)%x(2) * this%w2(n2)), &
                                c_double_complex)
                    val = expfact1 * expfact2 * sample(i)%fx
                    buf(n1,n2,sample(i)%i) = buf(n1,n2,sample(i)%i) + val
                enddo
            enddo
        enddo
    end subroutine

    subroutine nfourier2d_postprocess(this, acc, res)
        class(matsubara_sampler_2d), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        ! divide by beta for mapping of two time arguments to one
        res(:,:) = acc(:,:) / this%beta
    end subroutine

    ! --- LEGENDRE ROUTINES

    subroutine legendre_init(this_s, ncomp, beta, statsign, nleg, coeff)
        class(DSampler), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign, nleg
        real(c_double), intent(in) :: beta, coeff

        type(legendre_sampler), allocatable :: this

        allocate(this)
        call sampler_init(this, ncomp, nleg, nleg, beta, statsign, coeff)
        this%nleg = nleg

        call move_alloc(this, this_s)
    end subroutine

    subroutine legendre_add(this, sample, acc)
        class(legendre_sampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        real(c_double), intent(inout) :: acc(0:this%nacc-1, this%ncomp)

        real(c_double) :: p0, p1, pnext, scaledx
        integer(c_int64_t) :: i, n
        type(DSamplePoint) :: curr

        ! Evaluate polynomials at the given points
        do i = 1, size(sample)
            curr = sample_wraptau(this, sample(i))
            scaledx = 2.0d0 / this%beta * curr%x - 1
            p0 = curr%fx
            p1 = p0 * scaledx
            if (this%nleg > 0) then
                acc(0, curr%i) = acc(0, curr%i) + p0
            endif
            if (this%nleg > 1) then
                acc(1, curr%i) = acc(1, curr%i) + p1
            endif
            do n = 2, this%nleg - 1
                ! Use Bonnet's recursion formula
                pnext = ((2 * n - 1) * scaledx * p1 - (n - 1) * p0) / n
                acc(n , curr%i) = acc(n, curr%i) + pnext
                ! Shift by one
                p0 = p1
                p1 = pnext
            enddo
        enddo
    end subroutine

    subroutine legendre_postprocess(this, acc, res)
        class(legendre_sampler), intent(inout) :: this
        real(c_double), intent(in), target :: acc(0:this%nacc-1, this%ncomp)
        real(c_double), intent(out), target :: res(0:this%npost-1, this%ncomp)

        integer :: i

        ! The sqrt(2 * i + 1) comes from the quite strange normalization of
        ! the polynomials in [1].  Orthornormal functions constructed
        ! from scaled Legendre polynomials `P(i,x)` would look like this:
        !
        !    G(i, tau) = sqrt((2 * i + 1)/beta) * P(i, 2/beta * tau - 1)
        !
        ! However, Ref. [1] includes an additional 1/sqrt(beta), which is why
        ! we must leave out that factor in computing the overlaps.
        ! The 1/beta instead is from the reduction from two to one time
        ! argument.
        !
        ! [1] Boehnke et al, PRB 84, 075145 (2011)
        do i = 0, this%nleg-1
            res(i,:) = acc(i,:) * (sqrt(2 * i + 1.0d0) / this%beta)
        enddo
    end subroutine

    ! --- NFFT ROUTINES

    subroutine nfft_init(this_s, ncomp, beta, statsign, niw, sparse_frequencies, coeff, use_fftw, use_sparse)
        class(DSampler), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign, niw
        logical, intent(in) :: use_fftw
        integer, intent(in) :: sparse_frequencies(niw)
        logical, intent(in) :: use_sparse
        integer ::  n, zeta
        real(c_double), intent(in) :: beta, coeff

        type(nfft_sampler), allocatable :: this
        integer :: in_grid

        allocate(this)

        ! Construct frequencies
        !allocate(this%w, source=default_frequencies(niw, statsign))
        if (use_sparse) then
            allocate(this%w, source=sparse_frequencies)
        else
            allocate(this%w, source=default_frequencies(niw, statsign))
        end if

        ! Compute the frequency index of largest sampling frequency for NFFT routine
        zeta  = (1 - statsign) / 2
        n = (sparse_frequencies(niw) - zeta)/2 + 1
        ! Initialze window
        ! frequencies *2 for +/- and *2 for doubled interval
        if (use_sparse) then
            call gauss_init(this%window, 13, 4 * n, 4)
        else
            call gauss_init(this%window, 13, 4 * niw, 4)
        end if

        this%nextgrid = this%window%ngrid + 2 * this%window%m

        call sampler_init(this, ncomp, this%nextgrid, size(this%w), &
                          beta, statsign, coeff)

        ! Initialize the arrays
        in_grid = this%window%ngrid
        allocate(this%fft_in(0:in_grid-1, this%ncomp))
        allocate(this%fft_out(0:in_grid-1, this%ncomp))

        ! Create the FFTW plan if available, else at least allocate temporary
        ! space for the folding operation
        if (have_fftw .and. use_fftw) then
            call nfft_init_fftw(this)
        else
            this%fft_plan = c_null_ptr
        endif

        call move_alloc(this, this_s)
    end subroutine

    subroutine nfft_init_fftw(this)
        type(nfft_sampler), intent(inout) :: this

        integer(c_int) :: rank, howmany, istride, idist, ostride, odist
        integer(c_int), target :: n(1), inembed(1), onembed(1)

        integer(c_int) :: in_grid, out_grid

        in_grid = size(this%fft_in, 1)
        out_grid = size(this%fft_out, 1)

        rank = 1
        n(1) = in_grid
        howmany = this%ncomp

        istride = 1
        idist = istride * in_grid
        inembed(1) = in_grid

        ostride = 1
        odist = out_grid
        onembed(1) = out_grid

        this%fft_plan = fftw_plan_many_dft( &
                                rank, n, howmany, &
                                this%fft_in, inembed, istride, idist, &
                                this%fft_out, onembed, ostride, odist, &
                                FFTW_FORWARD, FFTW_MEASURE)

        if (.not. c_associated(this%fft_plan)) then
            stop '[nfft_init_fftw] error initializing FFTW plan'
        endif
    end subroutine

    subroutine nfft_delete(this)
        class(nfft_sampler), intent(inout) :: this

        ! Destroy the FFTW plan if present
        if (c_associated(this%fft_plan)) then
            call fftw_destroy_plan(this%fft_plan)
        endif
    end subroutine

    pure function nfft_map_sample(this, sample) result(res)
        type(nfft_sampler), intent(in) :: this
        type(DSamplePoint), intent(in) :: sample
        type(DSamplePoint) :: res

        res = sample

        ! Scale quantities to interval -0.5 ... 0.5 and then rotate it forward
        ! to the unit interval 0 ... 1
        res%x = 1/(2 * this%beta) * sample%x
        if (sample%x < 0) then
            res%x = res%x + 1
        end if

        ! TODO: remove 0.5 * sgn(tau) in the fermionic case in order to get
        !       continuous function.
    end function

    subroutine nfft_add(this, sample, acc)
        class(nfft_sampler), intent(inout) :: this
        type(DSamplePoint), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout) :: acc(this%nacc, this%ncomp)

        real(c_double) :: pos
        integer :: i, base
        type(DSamplePoint) :: curr
        logical, parameter :: debug_gauss = .false.

        ! Sort of implements Keiner et al. (2009), Alg. 3, formula 1.
        !
        ! For pos being an exact integer we would actually have 2n+1 points,
        ! but we can conceptually replace t -> t - epsilon, thereby eliminating
        ! the additional point (it lies epsilon outside [-m,m]).
        do i = 1, size(sample)
            curr = nfft_map_sample(this, sample(i))
            pos = curr%x * this%window%ngrid + this%window%m + 1
            base = int(pos)
            if (debug_gauss) then
                call gauss_add_slow(this%window, acc(:, curr%i), &
                                    base, pos - base, curr%fx)
            else
                call gauss_add_fast(this%window, acc(:, curr%i), &
                                    base, pos - base, curr%fx)
            endif
        enddo
    end subroutine

    subroutine nfft_foldback(this, acc, out)
        class(nfft_sampler), intent(in) :: this
        complex(c_double_complex), intent(in) :: acc(this%nextgrid, this%ncomp)
        complex(c_double_complex), intent(out) :: out(this%window%ngrid, this%ncomp)

        integer :: ngrid, m

        ! Otherwise the expressions become messy
        ngrid = this%window%ngrid
        m = this%window%m

        ! Fold back spills (window contributions outside of interval
        ! from points close to its edges) to interval
        !TODO: optimize for possibility that acc and out may be real
        out(1:ngrid, :) = acc(m+1:ngrid+m, :)
        out(1:m, :) = out(1:m, :) + acc(ngrid+m+1:, :)
        out(ngrid-m+1:ngrid, :) = out(ngrid-m+1:ngrid, :) + acc(1:m, :)
    end subroutine

    subroutine dft_naive(this, res)
        class(nfft_sampler), intent(in) :: this
        complex(c_double_complex), intent(out) :: res(this%npost, this%ncomp)

        integer :: k, j
        real(c_double) :: twopi_n
        complex(c_double_complex) :: expfact

        res(:, :) = 0
        twopi_n = 2 * PI / this%window%ngrid
        do k = 1, this%npost
            do j = 0, this%window%ngrid-1
                expfact = cmplx(cos(twopi_n * this%w(k) * j), &
                                sin(twopi_n * this%w(k) * j), &
                                kind=c_double_complex)
                res(k, :) = res(k, :) + expfact * this%fft_in(j, :)
            enddo
        enddo
    end subroutine

    subroutine dft_fast(this, res)
        class(nfft_sampler), intent(inout) :: this
        complex(c_double_complex), intent(out) :: res(this%npost, this%ncomp)

        integer :: i, k, N, kfreq

        ! Perform r2c FFTW transform
        ! NOTE: http://fftw.org/doc/FFTW-Execution-in-Fortran.html
        call fftw_execute_dft(this%fft_plan, this%fft_in, this%fft_out)

        ! We now did the following which is always a FORWARD transform:
        !
        !     fft_out(n) = sum(exp(-2*pi*i/N * k * n) * fft_in(k), k)
        !
        ! on half the input. Replacing n -> N - n, we get the the backward
        ! transform we actually want:
        !
        !     out(n) = fft_out(-n) = fft_out((N - n) mod N)
        !
        N = size(this%fft_out, 1)
        do i = 1, this%ncomp
            do k = 1, this%npost
                kfreq = -this%w(k)
                if (kfreq < 0) &
                    kfreq = kfreq + N
                res(k, i) = this%fft_out(kfreq, i)
            enddo
        enddo
    end subroutine

    subroutine nfft_inv_conv(this, res)
        class(nfft_sampler), intent(inout) :: this
        complex(c_double_complex), intent(out) :: res(this%npost, this%ncomp)

        real(c_double) :: phihat
        integer :: k

        ! Inverse convolution
        do k = 1, this%npost
            phihat = gauss_phihat(this%window, this%w(k))
            res(k,:) = res(k,:) / (this%window%ngrid * phihat)
        end do
    end subroutine

    subroutine nfft_postprocess(this, acc, res)
        use MPrinting
        class(nfft_sampler), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)

        call nfft_foldback(this, acc, this%fft_in)

        if (c_associated(this%fft_plan)) then
            call dft_fast(this, res)
        else
            call dft_naive(this, res)
        endif

        call nfft_inv_conv(this, res)

        ! Proper scaling
        res(:,:) = 1/this%beta * res(:,:)
    end subroutine

    subroutine nfft2d_init(this_s, ncomp, beta, statsign, niw, coeffs, use_fftw)
        class(DSampler2D), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign(2), niw(2)
        logical, intent(in) :: use_fftw
        real(c_double), intent(in) :: beta, coeffs(2, 2)

        type(nfft_sampler2d), allocatable :: this
        integer :: in_grid(2)

        allocate(this)

        ! Construct frequencies
        allocate(this%w1, source=default_frequencies(niw(1), statsign(1)))
        allocate(this%w2, source=default_frequencies(niw(2), statsign(2)))

        ! Initialize window
        ! frequencies *2 for +/- and *2 for doubled interval
        call gauss_init(this%window(1), 13, 4 * niw(1), 4)
        call gauss_init(this%window(2), 13, 4 * niw(2), 4)

        this%nextgrid(:) = this%window(:)%ngrid + 2 * this%window(:)%m

        call sampler2d_init(this, ncomp, product(this%nextgrid), &
                            size(this%w1) * size(this%w2), &
                            beta, statsign, coeffs)

        ! Initialize the arrays
        in_grid(:) = this%window(:)%ngrid
        allocate(this%fft_in(0:in_grid(1) - 1, 0:in_grid(2) - 1, this%ncomp))
        allocate(this%fft_out(0:in_grid(1) - 1, 0:in_grid(2) - 1, this%ncomp))

        ! Create the FFTW plan if available, else at least allocate temporary
        ! space for the folding operation
        if (have_fftw .and. use_fftw) then
            call nfft2d_init_fftw(this)
        else
            this%fft_plan = c_null_ptr
        end if

        call move_alloc(this, this_s)
    end subroutine nfft2d_init

    subroutine nfft2d_init_fftw(this)
        type(nfft_sampler2d), intent(inout) :: this

        integer(c_int) :: rank, howmany, istride, idist, ostride, odist
        integer(c_int), target :: n(2), inembed(2), onembed(2)

        integer(c_int) :: in_grid(2), out_grid(2)

        in_grid = [size(this%fft_in, 2), size(this%fft_in, 1)]
        out_grid = [size(this%fft_out, 2), size(this%fft_out, 1)]

        rank = 2
        n(:) = in_grid
        howmany = this%ncomp

        istride = 1
        idist = istride * product(in_grid)
        inembed(:) = in_grid

        ostride = 1
        odist = ostride * product(out_grid)
        onembed(:) = out_grid

        this%fft_plan = fftw_plan_many_dft( &
                                rank, n, howmany, &
                                this%fft_in, inembed, istride, idist, &
                                this%fft_out, onembed, ostride, odist, &
                                FFTW_FORWARD, FFTW_MEASURE)

        if (.not. c_associated(this%fft_plan)) then
            error stop '[nfft2d_init_fftw] error initializing FFTW plan'
        end if
    end subroutine nfft2d_init_fftw

    subroutine nfft2d_delete(this)
        class(nfft_sampler2d), intent(inout) :: this

        ! Destroy the FFTW plan if present
        if (c_associated(this%fft_plan)) then
            call fftw_destroy_plan(this%fft_plan)
        end if
    end subroutine nfft2d_delete

    pure function nfft2d_map_sample(this, sample) result(res)
        type(nfft_sampler2d), intent(in) :: this
        type(DSamplePoint2D), intent(in) :: sample
        type(DSamplePoint2D) :: res

        res = sample

        ! Scale quantities to interval -0.5 ... 0.5 and then rotate it forward
        ! to the unit interval 0 ... 1
        res%x = 1/(2 * this%beta) * sample%x
        res%x = modulo(res%x, 1.0d0)

        !res%x(1) = 1/(this%beta) * sample%x(1) - 0.5
        !res%x(2) = 1/(this%beta) * sample%x(2) + 0.5
        !res%x = modulo(res%x, 1.0d0)

        ! TODO: remove 0.5 * sgn(tau) in the fermionic case in order to get
        !       continuous function.
    end function nfft2d_map_sample

    subroutine nfft2d_add(this, sample, acc)
        class(nfft_sampler2d), intent(inout) :: this
        type(DSamplePoint2D), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), pointer :: acc2d(:, :, :)

        real(c_double) :: pos(2)
        integer :: i, base(2)
        type(DSamplePoint2D) :: curr
        logical, parameter :: debug_gauss = .false.

        acc2d(1:this%nextgrid(1), 1:this%nextgrid(2), 1:this%ncomp) => acc

        ! Sort of implements Keiner et al. (2009), Alg. 3, formula 1.
        !
        ! For pos being an exact integer we would actually have 2n+1 points,
        ! but we can conceptually replace t -> t - epsilon, thereby eliminating
        ! the additional point (it lies epsilon outside [-m,m]).
        do i = 1, size(sample)
            curr = nfft2d_map_sample(this, sample(i))
            pos = curr%x * this%window(:)%ngrid + this%window(:)%m + 1
            base = int(pos)
            if (debug_gauss) then
                call gauss_add2d_slow(this%window, acc2d(:, :, curr%i), &
                                      base, pos - base, curr%fx)
            else
                call gauss_add2d_fast(this%window, acc2d(:, :, curr%i), &
                                      base, pos - base, curr%fx)
            endif
        enddo
    end subroutine nfft2d_add

    subroutine nfft2d_foldback(this, acc, out)
        class(nfft_sampler2d), intent(in) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out) :: out(this%window(1)%ngrid,&
                                         this%window(2)%ngrid,&
                                         this%ncomp)
        complex(c_double_complex), pointer :: acc2d(:, :, :)

        integer :: ngrid(2), m(2), cf(2), cl(2), omtl(2), amtl(2)

        acc2d(1:this%nextgrid(1), 1:this%nextgrid(2), 1:this%ncomp) => acc

        ! Otherwise the expressions become messy
        ngrid = this%window(:)%ngrid
        m = this%window(:)%m

        cf = m + 1  ! center first in acc2d
        cl = m + ngrid  ! center last in acc2d
        omtl = ngrid - m + 1  ! m to last in out
        amtl = ngrid + m + 1  ! m to last in acc2d

        ! Fold back spills (window contributions outside of interval
        ! from points close to its edges) to interval
        !TODO: optimize for possibility that acc and out may be real

        ! center
        out(:, :, :) =&
             acc2d(cf(1):cl(1), cf(2):cl(2), :)

        ! fold back 2 * 2 edges
        out(1:m(1), :, :) =&
             out(1:m(1), :, :)&
             + acc2d(amtl(1):, cf(2):cl(2), :)
        out(omtl(1):ngrid(1), :, :) =&
             out(omtl(1):ngrid(1), :, :)&
             + acc2d(1:m(1), cf(2):cl(2), :)

        out(:, 1:m(2), :) =&
             out(:, 1:m(2), :)&
             + acc2d(cf(1):cl(1), amtl(2):, :)
        out(:, omtl(2):ngrid(2), :) =&
             out(:, omtl(2):ngrid(2), :)&
             + acc2d(cf(1):cl(1), 1:m(2), :)

        ! fold back 2 ^ 2 corners
        out(1:m(1), 1:m(2), :) =&
             out(1:m(1), 1:m(2), :)&
             + acc2d(amtl(1):, amtl(2):, :)
        out(1:m(1), omtl(2):ngrid(2), :) =&
             out(1:m(1), omtl(2):ngrid(2), :)&
             + acc2d(amtl(1):, 1:m(2), :)
        out(omtl(1):ngrid(1), omtl(2):ngrid(2), :) =&
             out(omtl(1):ngrid(1), omtl(2):ngrid(2), :)&
             + acc2d(1:m(1), 1:m(2), :)
        out(omtl(1):ngrid(1), 1:m(2), :) =&
             out(omtl(1):ngrid(1), 1:m(2), :)&
             + acc2d(1:m(1), omtl(2):ngrid(2), :)
    end subroutine nfft2d_foldback

    subroutine dft2d_naive(this, res)
        class(nfft_sampler2d), intent(in) :: this
        complex(c_double_complex), intent(out) :: res(size(this%w1), size(this%w2), this%ncomp)

        integer :: k, j, l, m
        real(c_double) :: twopi_n(2)
        complex(c_double_complex) :: expfact(2)

        res(:, :, :) = 0
        twopi_n(:) = 2 * PI / this%window(:)%ngrid
        do k = 1, size(res, 2)
           do j = 0, this%window(2)%ngrid - 1
              expfact(2) = cmplx(cos(twopi_n(2) * this%w2(k) * j), &
                                 sin(twopi_n(2) * this%w2(k) * j), &
                                 kind=c_double_complex)
              do l = 1, size(res, 1)
                 do m = 0, this%window(1)%ngrid - 1
                    expfact(1) = cmplx(cos(twopi_n(1) * this%w1(l) * m), &
                                       sin(twopi_n(1) * this%w1(l) * m), &
                                       kind=c_double_complex)

                    res(l, k, :) = res(l, k, :) + product(expfact) * this%fft_in(m, j, :)
                 end do
              end do
            end do
        end do
    end subroutine dft2d_naive

    subroutine dft2d_fast(this, res)
        class(nfft_sampler2d), intent(inout) :: this
        complex(c_double_complex), intent(out) :: res(size(this%w1), size(this%w2), this%ncomp)

        integer :: i, j, k, N(2), jfreq, kfreq

        ! Perform FFTW transform
        ! NOTE: http://fftw.org/fftw3_doc/Plan-execution-in-Fortran.html
        call fftw_execute_dft(this%fft_plan, this%fft_in, this%fft_out)

        ! We now did the following which is always a FORWARD transform:
        !
        !     fft_out(n) = sum(exp(-2*pi*i/N * k * n) * fft_in(k), k)
        !
        ! on half the input. Replacing n -> N - n, we get the the backward
        ! transform we actually want:
        !
        !     out(n) = fft_out(-n) = fft_out((N - n) mod N)
        !
        N = [size(this%fft_out, 1), size(this%fft_out, 2)]
        do i = 1, this%ncomp
           do k = 1, size(this%w2)
              kfreq = -this%w2(k)
              if (kfreq < 0) &
                   kfreq = kfreq + N(2)

              do j = 1, size(this%w1)
                 jfreq = -this%w1(j)
                 if (jfreq < 0) &
                      jfreq = jfreq + N(1)

                 res(j, k, i) = this%fft_out(jfreq, kfreq, i)
              end do
            end do
        end do

        !res(:,:,:) = this%fft_out(:,:,:)
    end subroutine dft2d_fast

    subroutine nfft2d_inv_conv(this, res)
        class(nfft_sampler2d), intent(inout) :: this
        complex(c_double_complex), intent(out) :: res(size(this%w1), size(this%w2), this%ncomp)

        real(c_double) :: phihat1, phihat2
        integer :: j, k, ngrids

        ngrids = product(this%window(:)%ngrid)

        ! Inverse convolution
        do k = 1, size(this%w2)
           phihat2 = gauss_phihat(this%window(2), this%w2(k))
           do j = 1, size(this%w1)
              phihat1 = gauss_phihat(this%window(1), this%w1(j))
              res(j, k, :) = res(j, k, :) / (ngrids * phihat1 * phihat2)
           end do
        end do
    end subroutine nfft2d_inv_conv

    subroutine nfft2d_postprocess(this, acc, res)
        class(nfft_sampler2d), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)
        complex(c_double_complex), pointer :: res2d(:, :, :)

        res2d(1:size(this%w1), 1:size(this%w2), 1:this%ncomp) => res

        call nfft2d_foldback(this, acc, this%fft_in)

        if (c_associated(this%fft_plan)) then
            call dft2d_fast(this, res2d)
        else
            call dft2d_naive(this, res2d)
        endif

        call nfft2d_inv_conv(this, res2d)

        ! Proper scaling
        res2d(:, :, :) = 1/this%beta * res2d(:, :, :)

        !forall(i=1:size(this%w1), j=1:size(this%w2), mod(i+j,2)==1) &
        !    res2d(i,j,:) = -res2d(i,j,:)
    end subroutine nfft2d_postprocess

    subroutine nfft3d_init(this_s, ncomp, beta, statsign, niw, coeffs, use_fftw)
        class(DSampler3D), allocatable, intent(inout) :: this_s
        integer, intent(in) :: ncomp, statsign(3), niw(3)
        logical, intent(in) :: use_fftw
        real(c_double), intent(in) :: beta, coeffs(3, 3)

        type(nfft_sampler3d), allocatable :: this
        integer :: in_grid(3)

        allocate(this)

        ! Construct frequencies
        allocate(this%w1, source=default_frequencies(niw(1), statsign(1)))
        allocate(this%w2, source=default_frequencies(niw(2), statsign(2)))
        allocate(this%w3, source=default_frequencies(niw(3), statsign(3)))

        ! Initialize window
        ! frequencies *2 for +/- and *2 for doubled interval
        call gauss_init(this%window(1), 13, 4 * niw(1), 4)
        call gauss_init(this%window(2), 13, 4 * niw(2), 4)
        call gauss_init(this%window(3), 13, 4 * niw(3), 4)

        this%nextgrid(:) = this%window(:)%ngrid + 2 * this%window(:)%m

        call sampler3d_init(this, ncomp, product(this%nextgrid), &
                            size(this%w1) * size(this%w2) * size(this%w3), &
                            beta, statsign, coeffs)

        ! Initialize the arrays
        in_grid(:) = this%window(:)%ngrid
        allocate(this%fft_in(0:in_grid(1) - 1, 0:in_grid(2) - 1, 0:in_grid(3) - 1, this%ncomp))
        allocate(this%fft_out(0:in_grid(1) - 1, 0:in_grid(2) - 1, 0:in_grid(3) - 1, this%ncomp))

        ! Create the FFTW plan if available, else at least allocate temporary
        ! space for the folding operation
        if (have_fftw .and. use_fftw) then
            call nfft3d_init_fftw(this)
        else
            this%fft_plan = c_null_ptr
        end if

        call move_alloc(this, this_s)
    end subroutine nfft3d_init

    subroutine nfft3d_init_fftw(this)
        type(nfft_sampler3d), intent(inout) :: this

        integer(c_int) :: rank, howmany, istride, idist, ostride, odist
        integer(c_int), target :: n(3), inembed(3), onembed(3)

        integer(c_int) :: in_grid(3), out_grid(3)

        in_grid = [size(this%fft_in, 3), size(this%fft_in, 2), size(this%fft_in, 1)]
        out_grid = [size(this%fft_out, 3), size(this%fft_out, 2), size(this%fft_out, 1)]

        rank = 3
        n(:) = in_grid
        howmany = this%ncomp

        istride = 1
        idist = istride * product(in_grid)
        inembed(:) = in_grid

        ostride = 1
        odist = ostride * product(out_grid)
        onembed(:) = out_grid

        this%fft_plan = fftw_plan_many_dft( &
                                rank, n, howmany, &
                                this%fft_in, inembed, istride, idist, &
                                this%fft_out, onembed, ostride, odist, &
                                FFTW_FORWARD, FFTW_MEASURE)

        if (.not. c_associated(this%fft_plan)) then
            error stop '[nfft3d_init_fftw] error initializing FFTW plan'
        end if
    end subroutine nfft3d_init_fftw

    subroutine nfft3d_delete(this)
        class(nfft_sampler3d), intent(inout) :: this

        ! Destroy the FFTW plan if present
        if (c_associated(this%fft_plan)) then
            call fftw_destroy_plan(this%fft_plan)
        end if
    end subroutine nfft3d_delete

    pure function nfft3d_map_sample(this, sample) result(res)
        type(nfft_sampler3d), intent(in) :: this
        type(DSamplePoint3D), intent(in) :: sample
        type(DSamplePoint3D) :: res

        res = sample

        ! Scale quantities to interval -0.5 ... 0.5 and then rotate it forward
        ! to the unit interval 0 ... 1
        res%x = 1/(2 * this%beta) * sample%x
        res%x = modulo(res%x, 1.0d0)

        ! TODO: remove 0.5 * sgn(tau) in the fermionic case in order to get
        !       continuous function.
    end function nfft3d_map_sample

    subroutine nfft3d_add(this, sample, acc)
        class(nfft_sampler3d), intent(inout) :: this
        type(DSamplePoint3D), intent(in) :: sample(:)
        complex(c_double_complex), intent(inout), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), pointer :: acc3d(:, :, :, :)

        real(c_double) :: pos(3)
        integer :: i, base(3)
        type(DSamplePoint3D) :: curr
        logical, parameter :: debug_gauss = .false.

        acc3d(1:this%nextgrid(1), 1:this%nextgrid(2), 1:this%nextgrid(3),&
             1:this%ncomp) => acc

        ! Sort of implements Keiner et al. (2009), Alg. 3, formula 1.
        !
        ! For pos being an exact integer we would actually have 2n+1 points,
        ! but we can conceptually replace t -> t - epsilon, thereby eliminating
        ! the additional point (it lies epsilon outside [-m,m]).
        do i = 1, size(sample)
            curr = nfft3d_map_sample(this, sample(i))
            pos = curr%x * this%window(:)%ngrid + this%window(:)%m + 1
            base = int(pos)
            if (debug_gauss) then
                call gauss_add3d_slow(this%window, acc3d(:, :, :, curr%i), &
                                      base, pos - base, curr%fx)
            else
                call gauss_add3d_fast(this%window, acc3d(:, :, :, curr%i), &
                                      base, pos - base, curr%fx)
            endif
        enddo
    end subroutine nfft3d_add

    subroutine nfft3d_foldback(this, acc, out)
        class(nfft_sampler3d), intent(in) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out) :: out(this%window(1)%ngrid,&
                                         this%window(2)%ngrid,&
                                         this%window(3)%ngrid,&
                                         this%ncomp)
        complex(c_double_complex), pointer :: acc3d(:, :, :, :)

        integer :: ngrid(3), m(3), i, j, k, x, y, z

        acc3d(1:this%nextgrid(1), 1:this%nextgrid(2), 1:this%nextgrid(3),&
             1:this%ncomp) => acc

        ! Otherwise the expressions become messy
        ngrid = this%window(:)%ngrid
        m = this%window(:)%m

        out(:, :, :, :) = 0

        do k = 1, this%nextgrid(3)
           do j = 1, this%nextgrid(2)
              do i = 1, this%nextgrid(1)
                 x = modulo(i - m(1) - 1, ngrid(1)) + 1
                 y = modulo(j - m(2) - 1, ngrid(2)) + 1
                 z = modulo(k - m(3) - 1, ngrid(3)) + 1
                 out(x, y, z, :) = out(x, y, z, :) + acc3d(i, j, k, :)
              end do
           end do
        end do
    end subroutine nfft3d_foldback

    subroutine dft3d_naive(this, res)
        class(nfft_sampler3d), intent(in) :: this
        complex(c_double_complex), intent(out) :: res(size(this%w1), size(this%w2),&
                                         size(this%w3), this%ncomp)

        integer :: k, j, l, m, n, p
        real(c_double) :: twopi_n(3)
        complex(c_double_complex) :: expfact(3)

        res(:, :, :, :) = 0
        twopi_n(:) = 2 * PI / this%window(:)%ngrid
        do n = 1, size(res, 3)
           do p = 0, this%window(3)%ngrid - 1
              expfact(3) = cmplx(cos(twopi_n(3) * this%w3(n) * p), &
                                 sin(twopi_n(3) * this%w3(n) * p), &
                                 kind=c_double_complex)

              do k = 1, size(res, 2)
                 do j = 0, this%window(2)%ngrid - 1
                    expfact(2) = cmplx(cos(twopi_n(2) * this%w2(k) * j), &
                                       sin(twopi_n(2) * this%w2(k) * j), &
                                       kind=c_double_complex)

                    do l = 1, size(res, 1)
                       do m = 0, this%window(1)%ngrid - 1
                          expfact(1) = cmplx(cos(twopi_n(1) * this%w1(l) * m), &
                                             sin(twopi_n(1) * this%w1(l) * m), &
                                             kind=c_double_complex)

                          res(l, k, n, :) = res(l, k, n, :) &
                               + product(expfact) * this%fft_in(m, j, p, :)
                       end do
                    end do
                 end do
              end do
            end do
        end do
    end subroutine dft3d_naive

    subroutine dft3d_fast(this, res)
        class(nfft_sampler3d), intent(inout) :: this
        complex(c_double_complex), intent(out) :: res(size(this%w1), size(this%w2),&
                                         size(this%w3), this%ncomp)
        integer :: i, j, k, l, N(3), jfreq, kfreq, lfreq

        ! Perform FFTW transform
        ! NOTE: http://fftw.org/fftw3_doc/Plan-execution-in-Fortran.html
        call fftw_execute_dft(this%fft_plan, this%fft_in, this%fft_out)

        ! We now did the following which is always a FORWARD transform:
        !
        !     fft_out(n) = sum(exp(-2*pi*i/N * k * n) * fft_in(k), k)
        !
        ! on half the input. Replacing n -> N - n, we get the the backward
        ! transform we actually want:
        !
        !     out(n) = fft_out(-n) = fft_out((N - n) mod N)
        !
        N = [size(this%fft_out, 1), size(this%fft_out, 2), size(this%fft_out, 3)]
        do i = 1, this%ncomp
           do l = 1, size(this%w3)
              lfreq = -this%w3(l)
              if (lfreq < 0) &
                   lfreq = lfreq + N(3)

              do k = 1, size(this%w2)
                 kfreq = -this%w2(k)
                 if (kfreq < 0) &
                      kfreq = kfreq + N(2)

                 do j = 1, size(this%w1)
                    jfreq = -this%w1(j)
                    if (jfreq < 0) &
                         jfreq = jfreq + N(1)

                    res(j, k, l, i) = this%fft_out(jfreq, kfreq, lfreq, i)
                 end do
              end do
            end do
        end do
    end subroutine dft3d_fast

    subroutine nfft3d_inv_conv(this, res)
        class(nfft_sampler3d), intent(inout) :: this
        complex(c_double_complex), intent(out) :: res(size(this%w1), size(this%w2),&
                                         size(this%w3), this%ncomp)

        real(c_double) :: phihat1, phihat2, phihat3
        integer :: i, j, k, ngrids

        ngrids = product(this%window(:)%ngrid)

        ! Inverse convolution
        do k = 1, size(this%w3)
           phihat3 = gauss_phihat(this%window(3), this%w3(k))
           do j = 1, size(this%w2)
              phihat2 = gauss_phihat(this%window(2), this%w2(j))
              do i = 1, size(this%w1)
                 phihat1 = gauss_phihat(this%window(1), this%w1(i))
                 res(i, j, k, :) = res(i, j, k, :) / (ngrids * phihat1 &
                                                      * phihat2 * phihat3)
              end do
           end do
        end do
    end subroutine nfft3d_inv_conv

    subroutine nfft3d_postprocess(this, acc, res)
        class(nfft_sampler3d), intent(inout) :: this
        complex(c_double_complex), intent(in), target :: acc(this%nacc, this%ncomp)
        complex(c_double_complex), intent(out), target :: res(this%npost, this%ncomp)
        complex(c_double_complex), pointer :: res3d(:, :, :, :)

        res3d(1:size(this%w1), 1:size(this%w2), 1:size(this%w3), 1:this%ncomp) => res

        call nfft3d_foldback(this, acc, this%fft_in)

        if (c_associated(this%fft_plan)) then
            call dft3d_fast(this, res3d)
        else
            call dft3d_naive(this, res3d)
        endif

        call nfft3d_inv_conv(this, res3d)

        ! Proper scaling
        res3d(:, :, :, :) = 1/this%beta * res3d(:, :, :, :)
    end subroutine nfft3d_postprocess

    ! --- GAUSS WINDOW ROUTINES

    subroutine gauss_init(this, m, nfreq, sigma)
        type(gauss_window), intent(out) :: this
        integer, intent(in) :: m, nfreq, sigma

        integer :: l
        real(c_double) :: b

        if (sigma <= 0) &
            stop 'sigma must be positive'
        if (m <= 0 .or. m > nfreq) &
            stop 'illegal window length'

        this%m = m
        this%nfreq = nfreq
        this%ngrid = nfreq * sigma

        ! Follows Keiner et al. (2009) (DOI:10.1145/1555386.1555388),
        ! eq. (C.1)
        b = 2.0d0 * sigma / (2 * sigma - 1) * m / PI
        this%tnorm = 1 / sqrt(PI * b)
        this%texp = -1 / b
        this%knorm = 1.0d0 / this%ngrid
        this%kexp = -b * PI * PI / (1.0d0 * this%ngrid * this%ngrid)

        ! for -m < l <= m, precompute first term of:
        ! a * exp(c * (l-delta)**2)
        !      = a * exp(c * l**2) * exp(c * delta**2) * exp(-2 * c *delta)**l
        allocate(this%lfact(-m+1:m))
        do l = -m+1, m
            this%lfact(l) = this%tnorm * exp(this%texp * l * l)
        enddo
    end subroutine

    pure function gauss_phi(this, t) result(phit)
        type(gauss_window), intent(in) :: this
        real(c_double), intent(in) :: t
        real(c_double) :: phit

        if (t > -this%m .and. t <= this%m) then
            phit = this%tnorm * exp(this%texp * t * t)
        else
            phit = 0
        endif
    end function

    function gauss_phihat(this, k) result(phihatk)
        type(gauss_window), intent(in) :: this
        integer, intent(in) :: k
        real(c_double) :: phihatk

        if (k < -int(this%ngrid/2) .or. k >= int((this%ngrid + 1)/2)) &
            stop 'Window function undefined'

        phihatk = this%knorm * exp(this%kexp * k * k)
    end function

    subroutine gauss_add_slow(this, acc, pos, delta, fx)
        type(gauss_window), intent(in) :: this
        complex(c_double_complex), intent(inout) :: acc(:)
        real(c_double), intent(in) :: delta
        real(c_double), intent(in) :: fx
        integer, intent(in) :: pos

        integer :: l

        do l = -this%m + 1, this%m
            acc(pos + l) = acc(pos + l) + fx * gauss_phi(this, l - delta)
        enddo
    end subroutine

    subroutine gauss_add2d_slow(this, acc, pos, delta, fx)
        type(gauss_window), intent(in) :: this(2)
        complex(c_double_complex), intent(inout) :: acc(:, :)
        real(c_double), intent(in) :: delta(2)
        real(c_double), intent(in) :: fx
        integer, intent(in) :: pos(2)

        integer :: l1, l2

        do l1 = -this(1)%m + 1, this(1)%m
           do l2 = -this(2)%m + 1, this(2)%m
              acc(pos(1) + l1, pos(2) + l2) = acc(pos(1) + l1, pos(2) + l2)&
                   + fx * gauss_phi(this(1), l1 - delta(1)) * gauss_phi(this(2), l2 - delta(2))
           end do
        end do
    end subroutine gauss_add2d_slow

    subroutine gauss_add3d_slow(this, acc, pos, delta, fx)
        type(gauss_window), intent(in) :: this(3)
        complex(c_double_complex), intent(inout) :: acc(:, :, :)
        real(c_double), intent(in) :: delta(3)
        real(c_double), intent(in) :: fx
        integer, intent(in) :: pos(3)

        integer :: l1, l2, l3

        do l1 = -this(1)%m + 1, this(1)%m
           do l2 = -this(2)%m + 1, this(2)%m
              do l3 = -this(3)%m + 1, this(3)%m
                 acc(pos(1) + l1, pos(2) + l2, pos(3) + l3) = &
                      acc(pos(1) + l1, pos(2) + l2, pos(3) + l3)&
                      + fx * gauss_phi(this(1), l1 - delta(1))&
                           * gauss_phi(this(2), l2 - delta(2))&
                           * gauss_phi(this(3), l3 - delta(3))
              end do
           end do
        end do
    end subroutine gauss_add3d_slow

    subroutine gauss_add_fast(this, acc, pos, delta, fx)
        type(gauss_window), intent(in) :: this
        complex(c_double_complex), intent(inout) :: acc(:)
        real(c_double), intent(in) :: delta
        real(c_double), intent(in) :: fx
        integer, intent(in) :: pos

        integer :: l
        complex(c_double_complex) :: val
        real(c_double) :: step

        ! a * exp(c * (l-delta)**2)
        !     = (a * exp(c * l**2)) * exp(c * delta**2) * exp(-2 * c *delta)**l
        !     = lfact(l) * exp(c * delta * (delta + 2 * (m - 1)))
        !                * step**(l - (m + 1))
        val = fx * exp(this%texp * delta * (delta + 2 * (this%m - 1)))
        step = exp(-2 * this%texp * delta)
        do l = -this%m + 1, this%m
            acc(pos + l) = acc(pos + l) + val * this%lfact(l)
            val = val * step
        enddo
    end subroutine

    subroutine gauss_add2d_fast(this, acc, pos, delta, fx)
        type(gauss_window), intent(in) :: this(2)
        complex(c_double_complex), intent(inout) :: acc(:, :)
        real(c_double), intent(in) :: delta(2)
        real(c_double), intent(in) :: fx
        integer, intent(in) :: pos(2)

        integer :: l1, l2
        complex(c_double_complex) :: val(2), valprod
        real(c_double) :: step(2)

        ! same as 1d, but val(i > 1) remain fixed to reset the product
        ! after the inner loop(s)
        val(:) = exp(this(:)%texp * delta(:) * (delta(:) + 2 * (this(:)%m - 1)))
        step(:) = exp(-2 * this(:)%texp * delta(:))
        valprod = product(val)*fx
        do l1 = -this(1)%m + 1, this(1)%m
           do l2 = -this(2)%m + 1, this(2)%m
              acc(pos(1) + l1, pos(2) + l2) = acc(pos(1) + l1, pos(2) + l2)&
                   + valprod * this(1)%lfact(l1) * this(2)%lfact(l2)
              valprod = valprod * step(2)
           end do
           val(1) = val(1) * step(1)
           valprod = product(val)*fx
        end do
    end subroutine gauss_add2d_fast

    subroutine gauss_add3d_fast(this, acc, pos, delta, fx)
        type(gauss_window), intent(in) :: this(3)
        complex(c_double_complex), intent(inout) :: acc(:, :, :)
        real(c_double), intent(in) :: delta(3)
        real(c_double), intent(in) :: fx
        integer, intent(in) :: pos(3)

        integer :: l1, l2, l3
        complex(c_double_complex) :: val(3), valprod(2:3)
        real(c_double) :: step(3)

        ! same as 1d, but val(i > 1) remain fixed to reset the product
        ! after the inner loop(s)
        val(:) = exp(this(:)%texp * delta(:) * (delta(:) + 2 * (this(:)%m - 1)))
        step(:) = exp(-2 * this(:)%texp * delta(:))
        valprod(:) = product(val)*fx
        do l1 = -this(1)%m + 1, this(1)%m
           do l2 = -this(2)%m + 1, this(2)%m
              do l3 = -this(3)%m + 1, this(3)%m
                 acc(pos(1) + l1, pos(2) + l2, pos(3) + l3) =&
                      acc(pos(1) + l1, pos(2) + l2, pos(3) + l3)&
                      + valprod(3)&
                        * this(1)%lfact(l1)&
                        * this(2)%lfact(l2)&
                        * this(3)%lfact(l3)
                 valprod(3) = valprod(3) * step(3)
              end do
              valprod(2) = valprod(2) * step(2)
              valprod(3) = valprod(2)
           end do
           val(1) = val(1) * step(1)
           valprod(:) = product(val)*fx
        end do
    end subroutine gauss_add3d_fast

end module
