! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.

!> This module generates the Hamiltonian, creation and annihilation Operators.
!! They can then be stored in the type specified in MStates.
module MPsiD
    use iso_c_binding, only: c_double, c_double_complex
    use MExtRangeD
    use DMOperator
    use MStates
    implicit none
    private

    !> Set of creators/annihilators for the given system.
    !!
    !! Psis(b, s, i) are the fundamental operators for
    !!    - b ... orbital index (1, ..., Nbands)
    !!    - s ... spin index (1, 2)
    !!    - i ... 1 = creation; 2 = annihilation operator
    type, public :: DTPsis
        type(DTOperator), allocatable :: Psis(:,:,:)
    end type

    !> Initialize operator from states
    interface init_operator
       module procedure p_init_operator
    end interface
    public init_operator

    !> Initialize block-diagonal operator from states
    interface block_diagonal_oper
        module procedure p_block_diag
    end interface
    public block_diagonal_oper

    !> Initialize creators/annihilators in the occupation number basis
    interface init_psi
        module procedure p_init_psi
    end interface
    public init_psi

    !> Transform fundamental operators into the eigenbasis of the Hamiltonian
    interface transform_Psis
        module procedure p_transform_Psis
    end interface
    public transform_Psis

    !> Construct a Hamiltonian from parameters, updating states/psi
    interface make_hamiltonian
        module procedure p_make_hamiltonian
    end interface
    public make_hamiltonian

    !> Compute the one-particle reduced density matrix from the many-body rho
    interface rho1_from_density_matrix
        module procedure p_rho1_from_density_matrix
    end interface
    public :: rho1_from_density_matrix

    !> Compute the double occupation from the many-body rho
    interface double_occ_from_density_matrix
        module procedure p_double_occ_from_density_matrix
    end interface
    public :: double_occ_from_density_matrix

contains

    subroutine p_init_operator(this, dstates)
        type(DTOperator), intent(out) :: this
        type(TStates), intent(in) :: DStates
        integer :: nstates_blocks(DStates%NSStates)

        nstates_blocks(:) = DStates%SubStates(:)%NStates
        call init_operator(this, nstates_blocks)
    end subroutine

    subroutine p_block_diag(this,DStates)
        type(DTOperator), intent(out) :: this
        type(TStates), intent(in) :: DStates
        integer :: i, connect(DStates%NSStates), nstates_blocks(DStates%NSStates)

        nstates_blocks(:) = DStates%SubStates(:)%NStates
        connect(:) = (/ (i, i=0,DStates%NSStates-1) /)
        call init_operator(this, nstates_blocks, connect)
    end subroutine

    !> This subroutine allocates the arrays necessary to store the creation and
    !! annihilation operators.
    !! @params this a pointer to type DTPsis which is filled by this routine
    !! @params DStates holds information about the states of the system
    subroutine p_init_Psi(this,DStates)
        type(DTPsis), intent(out) :: this
        type(TStates), intent(in) :: DStates
        integer :: iB,iS,iI,iSSt1,iSSt2,iBand,iSpin
        integer :: iSt1,iSt2,State1,State2
        real(c_double) :: sig
        real(c_double), allocatable :: temp(:,:)
        integer, allocatable :: connect(:,:,:,:)

        ! allocate the necessary space for the dense psi matrices
        allocate(this%Psis(DStates%NBands,2,2))
        do iB=1,DStates%NBands
            do iS=1,2
                do iI=1,2
                    call init_operator(this%Psis(iB,iS,iI), dstates)
                enddo
            enddo
        enddo
        allocate(temp(0:DStates%NStates,0:DStates%NStates))

        allocate(connect(DStates%NBands,2,2,0:DStates%NSStates-1))
        connect(:,:,:,:) = -1

        !! generate the marices by counting hoppings over electrons
        !! (read phase factor *-1 from every hop)
        do iSSt1=0,DStates%NSStates-1
            do iSSt2=0,DStates%NSStates-1
                if(iSSt1.eq.iSSt2) &
                    cycle
                do iSpin=1,2
                do iBand=1,DStates%NBands
                    do iSt1=0,DStates%SubStates(iSSt1)%NStates-1
                    do iSt2=0,DStates%SubStates(iSSt2)%NStates-1
                        State1=DStates%SubStates(iSSt1)%States(iSt1)
                        State2=DStates%SubStates(iSSt2)%States(iSt2)
                        iI=(iBand-1)+DStates%NBands*(iSpin-1)
                        if(ieor(State1,State2).eq.ibset(0,iI))then
                            sig=1d0
                            spin: do iS=1,2
                            do iB=1,DStates%NBands
                                iI=(iB-1)+DStates%NBands*(iS-1)
                                if((iBand-1)+DStates%NBands*(iSpin-1).eq.iI) &
                                    exit spin
                                if(btest(State1,iI))then
                                    sig=sig*(-1d0)
                                endif
                            enddo
                            enddo spin
                            if(State2.gt.State1)then
                                connect(iBand,iSpin,1,iSSt1) = iSSt2
                            elseif(State2.lt.State1)then
                                connect(iBand,iSpin,2,iSSt1) = iSSt2
                            endif
                            temp(iSt2,iSt1)=sig
                        else
                            temp(iSt2,iSt1)=0d0
                        endif
                    enddo
                    enddo
                    if(connect(iBand,iSpin,1,iSSt1) .eq. iSSt2)then
                        call oper_set_block(this%Psis(iBand,iSpin,1), &
                                iSSt2, iSSt1, &
                                temp(0:DStates%SubStates(iSSt2)%NStates-1, &
                                     0:DStates%SubStates(iSSt1)%NStates-1) &
                                )
                    elseif(connect(iBand,iSpin,2,iSSt1) .eq. iSSt2)then
                        call oper_set_block(this%Psis(iBand,iSpin,2), &
                                iSSt2, iSSt1, &
                                temp(0:DStates%SubStates(iSSt2)%NStates-1, &
                                     0:DStates%SubStates(iSSt1)%NStates-1) &
                                )
                    endif
                enddo
                enddo
            enddo
        enddo
        deallocate(temp)
    end subroutine p_init_Psi

    subroutine p_make_hamiltonian(muimp, u_matrix, states, psi, hloc, qnthr)
        real(c_double), intent(in) :: muimp(:, :, :, :), u_matrix(:, :, :, :)
        real(c_double), intent(in) :: qnthr
        type(TStates), intent(inout) :: states
        type(DTPsis), intent(inout) :: psi
        type(DTOperator), intent(out) :: hloc
        type(TQNSpec) :: qnspec

        integer :: nbands
        integer, allocatable :: states2substates(:)

        qnspec = states%qnspec
        nbands = states%nbands

        ! Construct impurity Hamiltonian
        call block_diagonal_oper(hloc, states)
        call add_oneparticle_hamiltonian(hloc, psi, muimp)
        call add_u_hamiltonian(u_matrix, hloc, psi)
        call force_hermitian(hloc)

        ! Analyze quantum numbers
        if (qnspec%All) then
            call analyze_hamiltonian(hloc, states, states2substates, qnthr, .false.)
            deallocate(psi%psis)
            call dest_TOperator(hloc)
            call dest_States(states)

            ! Reconstruct states for new blocks
            call init_States(states, nbands, qnspec, states2substates)
            call init_Psi(psi, states)

            ! Reconstruct operator in the blocks
            call block_diagonal_oper(hloc, states)
            call add_oneparticle_hamiltonian(hloc, psi, muimp)
            call add_u_hamiltonian(u_matrix, hloc, psi)
            call force_hermitian(hloc)
        end if
    end subroutine

    !> we analyze the hamiltonian for the minimal block size and build
    !! up the array states2substates for later building the right
    !! substates.
    !!
    !! This proceeds as follows:
    !!- In each old superstate, 'nets' [subsets] of contained states that
    !!  are connected by application of the Hamiltonian (and thus mix under
    !!  time evolution) are constructed. A subset x is represented by a
    !!  slice nets(x, :), whose entries are the indices of the states it
    !!  contains in the States array of the old superstate or -1 at
    !!  'unoccupied' places (the nets array is preallocated to be able to
    !!  hold the maximum number of subsets with the maximum number of
    !!  subset members each). For initialization, the state with index 0 is
    !!  put into the first subset. Then, one loops over the subsets (index
    !!  net), over the contained states (index node) and over all states
    !!  (States-index edge) to find new states (edge) with non-zero
    !!  Hamiltonian matrix element (dh%subops(sst)%op(nets(net,node),edge)
    !!  between them and an already contained state (States-index nets(net,
    !!  node)), which are then appended to the subset (net) to be iterated
    !!  over in the "node"-loop. At the same time, the assignments of
    !!  states (bin. rep.) to newly subdivided superstates are kept track
    !!  of in states2substates, and when one has fully completed the
    !!  "node"-loop over a subset, another subset needs to be created if a
    !!  state in the old superstate that is not contained in a subset yet,
    !!  which is initialized with that state.
    !!
    !!- To fulfill the second condition for choosing superstates, that
    !!  application of a creator or annihilator may lead to at most one
    !!  other superstate, the mappings from states to superstates after
    !!  application of an operator are created (for each flavour & ca),
    !!  and if any two states from the same newly subdivided superstate
    !!  map to different superstates after the operator application, the
    !!  two target superstates are merged together (by assigning all
    !!  states contained in the one with higher index to the one with the
    !!  lower index and removing the former).
    !!
    !! we are doing the following for each substate in pseudo code:
    !!
    !! nets.append(net(nodes.pop))
    !!
    !! for net in nets
    !!   for node in net
    !!     for edge in node
    !!       if edge.node not in net
    !!           net.append(edge.node)
    !!           nodes.remove(edge.node)
    !!       end if
    !!     end for edge
    !!   end for node
    !!   if nodes are empty
    !!     done
    !!   else
    !!     nets.append(net(nodes.pop))
    !!   end if
    !! end for net
    !!
    subroutine analyze_hamiltonian(dh, dstates, states2substates, threshold, log)
        type(DTOperator) :: dh
        type(TStates),intent(in) :: dstates
        integer :: nsubstates
        integer, allocatable :: states2substates(:), cstates2substates(:)
        real(c_double), intent(in) :: threshold
        logical, intent(in) :: log
        real(c_double) :: maxignored
        integer, allocatable :: nets(:,:)
        integer :: sst, net, node, edge, netnode
        integer :: cstate,nstates
        integer :: idx, idx1, idx2
        integer :: empty_node, ib, is , ca
        integer :: bigger_substate, smaller_substate
        logical :: member, change
        real(c_double), allocatable :: op(:,:)

        if (.not.allocated(states2substates))&
            allocate(states2substates(0:dstates%nstates-1))
        if (.not.allocated(cstates2substates))&
            allocate(cstates2substates(0:dstates%nstates-1))
        states2substates(:) = -1
        nsubstates = -1
        nstates = dstates%nstates
        maxignored = 0.0d0

        do sst = 0, dstates%nsstates-1
            allocate(nets(0:dstates%substates(sst)%nstates-1, &
                        0:dstates%substates(sst)%nstates-1))
            nets(:,:) = -1
            nets(0,0) = 0
            nsubstates = nsubstates + 1
            states2substates(dstates%substates(sst)%states(0)) = nsubstates
        !     write(*,*)dh%subops(sst)%op
            call oper_get_block(dh, sst, sst, op)
            do net = 0, dstates%substates(sst)%nstates-1
                if (nets(net,0).eq.-1) exit
                do node = 0, dstates%substates(sst)%nstates-1
                    if (nets(net,node).eq.-1) exit
                    do edge = 0, dstates%substates(sst)%nstates-1
                        if (op(nets(net,node),edge).ne.0d0) then
                            if (abs(op(nets(net, node), edge)) > threshold) then
                                ! write(*,*)nets(net,node),edge,dh%subops(sst)%dOp(node,edge)
                                member = .false.
                                empty_node = -1
                                do netnode = 0, dstates%substates(sst)%nstates-1
                                    if (nets(net,netnode).eq.edge) then
                                        member = .true.
                                        exit
                                    else if (nets(net,netnode).eq.-1) then
                                        empty_node = netnode
                                        exit
                                    endif
                                enddo
                                if (.not.member) then
                                    if (empty_node < 0) &
                                        error stop 'empty node not set'
                                    nets(net,empty_node) = edge
                                    states2substates(dstates%substates(sst)%states(edge)) = &
                                        nsubstates
                                endif
                            else
                                maxignored = max(maxignored, &
                                    abs(op(nets(net, node), edge)))
                            end if
                        endif
                    enddo
                enddo
                do node = 0, dstates%substates(sst)%nstates-1
                    if (states2substates(dstates%substates(sst)%states(node)).eq.-1) then
                        nets(net+1,0) = node
                        nsubstates = nsubstates + 1
                        states2substates(dstates%substates(sst)%states(node)) = nsubstates
                        exit
                    endif
                enddo
            enddo
            deallocate(nets)
        enddo
        nsubstates = nsubstates + 1
    !   write(*,*)states2substates
    ! joing blocks which are doubly connected
        change = .true.
        outer: do while(change)
            change = .false.
            do ib = 1, dstates%nbands
            do is = 1, 2
            do ca = 1, 2
            cstates2substates(:) = -1
            do idx = 0, dstates%nstates-1
                if (.not.btest(dstates%statessstates(idx,1),(ib-1)+dstates%nbands*(is-1)).and.&
                    ca == 1)then
                    cstate = ibset(dstates%statessstates(idx,1),(ib-1)+dstates%nbands*(is-1))
                else if (btest(dstates%statessstates(idx,1),(ib-1)+dstates%nbands*(is-1)).and.&
                            ca == 2)then
                    cstate = ibclr(dstates%statessstates(idx,1),(ib-1)+dstates%nbands*(is-1))
                else
                    cstate = -1
                endif
                if (cstate.ne.-1)then
                    cstates2substates(dstates%statessstates(idx,1)) = states2substates(cstate)
                endif
            enddo
    !        write(*,*)"operator: ", ib,is,ca,cstates2substates
            do idx1 = 0, nstates-1
            do idx2 = idx1+1, nstates-1
                if(states2substates(dstates%statessstates(idx1,1)) == &
                    states2substates(dstates%statessstates(idx2,1)) .and.&
                    cstates2substates(dstates%statessstates(idx1,1)) /= &
                    cstates2substates(dstates%statessstates(idx2,1)) .and.&
                    cstates2substates(dstates%statessstates(idx1,1)) /= -1 .and.&
                    cstates2substates(dstates%statessstates(idx2,1)) /= -1) then
                    change = .true.
                    bigger_substate = &
                        max(cstates2substates(dstates%statessstates(idx1,1)),&
                            cstates2substates(dstates%statessstates(idx2,1)))
                    smaller_substate = &
                        min(cstates2substates(dstates%statessstates(idx1,1)),&
                            cstates2substates(dstates%statessstates(idx2,1)))
                    do idx = 0, nstates-1
                        if (states2substates(dstates%statessstates(idx,1)) == bigger_substate) then
                            states2substates(dstates%statessstates(idx,1)) = smaller_substate
                        endif
                        if (states2substates(dstates%statessstates(idx,1)) .gt. bigger_substate) then
                            states2substates(dstates%statessstates(idx,1)) = &
                            states2substates(dstates%statessstates(idx,1))-1
                        endif
                    enddo
                    cycle outer
                end if
            enddo
            enddo
    !        write(*,*)"states2substates:", states2substates
            enddo
            enddo
            enddo
        enddo outer
        nsubstates =  maxval(states2substates)+1
    !   write(*,*) states2substates
        if (log) then
            write (*,"('Analyzed Hamiltonian, found',I5,' blocks')") nsubstates
            if (maxignored > 0.0d0) then
                write (*, "(A, A, ES12.3)") &
                    "Maximum magnitude of entries potentially ignored ", &
                    "by automatic partitioning due to EPSBLOCK:", maxignored
            endif
        endif
    end subroutine

    !> Add interaction term corresponding to U to the Hamiltonian
    subroutine add_oneparticle_hamiltonian(h, DPsis, muimp)
        type(DTOperator), intent(inout) :: h
        type(DTPsis), intent(in) :: dpsis
        real(c_double), intent(in) :: muimp(:,:,:,:)

        integer :: b1, b2, sp1, sp2, nbands
        real(c_double) :: muimp_value

        nbands = size(dpsis%psis, 1)
        do b1 = 1,nbands
        do sp1 = 1,2
          do b2 = 1,nbands
          do sp2 = 1,2
                ! Check that U_1234 is non-zero (there is an interaction)
                muimp_value = muimp(b1,sp1,b2,sp2)
                if (muimp_value == 0) &
                    cycle

                call add_to_oper(h, &
                        matmul(DPsis%Psis(b1,sp1,1), DPsis%Psis(b2,sp2,2)), &
                        muimp_value)
          enddo
          enddo
        enddo
        enddo
    end subroutine

    !> Add interaction term corresponding to U to the Hamiltonian
    subroutine add_u_hamiltonian(u_matrix, h, dpsis)
        type(DTOperator), intent(inout) :: h
        type(DTPsis), intent(in) :: dpsis
        real(c_double), intent(in) :: u_matrix(:,:,:,:)

        integer :: b1, b2, b3, b4, sp1, sp2, sp3, sp4, nbands
        real(c_double) :: u_value
        type(DTOperator) :: op12, op124, op1243

        nbands = size(dpsis%psis, 1)
        do b1 = 1,NBands
        do sp1 = 1,2
            do b2 = 1,NBands
            do sp2 = 1,2
                op12 = matmul(DPsis%Psis(b1,sp1,1), DPsis%Psis(b2,sp2,1))
                do b4 = 1,NBands
                do sp4 = 1,2
                    op124 = matmul(op12, DPsis%Psis(b4,sp4,2))
                    do b3 = 1,NBands
                    do sp3 = 1,2
                        ! Check that U_1234 is non-zero (there is an interaction)
                        ! maybe TODO: this is dirty, since in the real case it
                        ! assigns a complex value to a real variable...
                        u_value = 0.5*u_matrix(2*(b1-1)+sp1, 2*(b2-1)+sp2, &
                                               2*(b3-1)+sp3, 2*(b4-1)+sp4)
                        if (u_value == 0) &
                            cycle

                        op1243 = matmul(op124, DPsis%Psis(b3,sp3,2))
                        call add_to_oper(h, op1243, u_value)
                    enddo
                    enddo
                enddo
                enddo
            enddo
            enddo
        enddo
        enddo
    end subroutine

    !> This subroutine transforms the DTPsis to the basis that is defined by the
    !! transformation-matrix HEVectors (in this case the eigenbasis of local
    !! Hamiltonian).
    subroutine p_transform_Psis(Eigen, transformed_Psis)
        type(DOperEigen), intent(in) :: Eigen
        type(DTPsis), intent(inout) :: transformed_Psis
        integer :: iB, iS, CA

        !generate psis in occupation-number-basis
        !call init_Psi(transformed_Psis,DStates)
        do iB=1,size(transformed_Psis%Psis(:,1,1))
        do iS=1,2
        do CA=1,2
            call transform_inv_eigenbasis(eigen, transformed_Psis%Psis(iB,iS,CA))
        enddo
        enddo
        enddo
    end subroutine

    function p_rho1_from_density_matrix(rho_mb, hloc, psis) result(rho1)
        type(DTOperator), intent(in) :: rho_mb
        type(DOperEigen), intent(in) :: hloc
        type(DTPsis), intent(in) :: psis
        real(c_double), allocatable :: rho1(:, :)

        integer :: ib2, is2, ib1, is1, iSSt
        integer :: nsstates, nbands

        type(DTKet) :: ket1, ket2
        type(DTBra) :: bra_rho
        type(DTOperator) :: rho_dag
        real(c_double) :: rho_entry

        nbands = size(psis%psis, 1)
        allocate(rho1(2*nbands, 2*nbands))
        rho1(:, :) = 0

        nsstates = get_num_superstates(rho_mb)
        rho_dag = adjoint(rho_mb)
        do iSSt=0,nsstates-1
            call set_to_operator(bra_rho, rho_dag, iSSt)

            do ib2=1,NBands
            do is2=1,2
                call set_to_operator(ket1, psis%psis(ib2,is2,2), iSSt)
                do ib1=1,NBands
                do is1=1,2
                    call apply_operator(ket2, psis%psis(ib1,is1,1), ket1)

                    rho_entry = limrange(braket_dotprod(bra_rho, ket2))
                    rho1(2*ib1-2+is1, 2*ib2-2+is2) = &
                        rho1(2*ib1-2+is1, 2*ib2-2+is2) + rho_entry
                enddo
                enddo
            enddo
            enddo
        enddo
    end

    function p_double_occ_from_density_matrix(rho_mb, hloc, psis) result(occ)
        type(DTOperator), intent(in) :: rho_mb
        type(DOperEigen), intent(in) :: hloc
        type(DTPsis), intent(in) :: psis
        real(c_double), allocatable :: occ(:, :, :, :)

        integer :: ib2, is2, ib1, is1, iSSt
        integer :: nsstates, nbands

        type(DTKet) :: ket, ket1, ket2, ketw
        type(DTBra) :: bra_rho
        type(DTOperator) :: rho_dag
        real(c_double) :: rho_entry

        nbands = size(psis%psis, 1)
        allocate(occ(nbands, 2, nbands, 2))
        occ(:,:,:,:) = 0

        nsstates = get_num_superstates(rho_mb)
        rho_dag = adjoint(rho_mb)
        do iSSt=0,nsstates-1
            call set_to_operator(bra_rho, rho_dag, iSSt)

            do ib2=1,NBands
            do is2=1,2
                call set_to_operator(ket, psis%psis(ib2,is2,2), isst)
                call apply_operator(ket1, psis%psis(ib2,is2,1), ket)
                do ib1=1,NBands
                do is1=1,2
                    call apply_operator(ketw, psis%psis(ib1,is1,2), ket1)
                    call apply_operator(ket2, psis%psis(ib1,is1,1), ketw)

                    rho_entry = limrange(braket_dotprod(bra_rho, ket2))
                    occ(ib1,is1,ib2,is2) = occ(ib1,is1,ib2,is2) + rho_entry
                enddo
                enddo
            enddo
            enddo
        enddo
    end

end module
