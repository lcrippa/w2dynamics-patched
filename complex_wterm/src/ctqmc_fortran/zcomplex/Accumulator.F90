! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.

!> Module providing statistical accumulator types
!!
!! This is similar to `boost::accumulators` in that it provides incremental
!! statistics
module MAccumulatorZ
    use iso_c_binding, only: c_int64_t, c_double, c_double_complex
    use MAccumulatorBase
    use MComplexNumbers, only: nan
    implicit none
    private

    type, private :: varatom
        ! Grouped to improve locality of reference
        ! sum of observations which will form the bin for the next level
        complex(c_double_complex) :: spill
        ! current mean of this level
        complex(c_double_complex) :: mean
        ! current sum of squared differences to the mean of this level
        real(c_double) :: sqdiff
    end type varatom

    !> Accumulator which tracks statistical aggregates.
    !!
    !! For a random vector (multivariate random variable) `X` with `k`
    !! components, tracks a (configurable) set of statistics, which are updated
    !! as one adds observations.  Depending on the type, track:
    !!
    !!   - `ACC_NULL`: number of observations
    !!   - `ACC_MEAN`: sample mean (empirical mean)
    !!   - `ACC_BLOCKS`: stack of sample covariances
    !!
    !! The costs are summarized in the following table, where `n` is the number
    !! of observation
    !!
    !!   | Statistic   | Memory      | Runtime  |
    !!   | ----------- | ----------- | -------- |
    !!   | ACC_NULL    | O(1)        | O(n)     |
    !!   | ACC_MEAN    | O(k)        | O(k*n)   |
    !!   | ACC_BLOCKS  | O(k*log(n)) | O(k*n)   |
    !!
    type, public :: ZAccumulator
        private
        ! buffer for accumulation: this is used as simple sum, which is then
        ! turned into the mean for ACC_MEAN
        complex(c_double_complex), allocatable :: buffer(:)
        ! stack of variances
        type(varatom), allocatable :: dat(:,:)
        ! number of values, number of components in the random vector
        integer(c_int64_t) :: n, ncomp
    end type

    !>     call accumulator_init(acc, typ, ncomp, nblocks)
    !!
    !! Set up an accumulator to store statistics for a random vector.
    !!
    !!  @param acc: the accumulator to initialize
    !!  @param typ: statistic to track, any combination of `ACC_*` flags
    !!  @param ncomp: number of components in the random vector
    !!  @param nblocks: number of blocks to use for the variance stack
    !!
    interface accumulator_init
        module procedure p_accumulator_init
    end interface
    public accumulator_init

    !>     call accumulator_add(acc)
    !!
    !! Commit the value added to the buffer as new observation to the
    !! accumulator and update the statstical aggregates.
    interface accumulator_add
        module procedure p_accumulator_add
    end interface
    public accumulator_add

    !>     call accumulator_buffer(acc, buf)
    !!
    !! Get a pointer to the buffer, to which one should *add* the data for the
    !! current observation.
    interface accumulator_buffer
       module procedure p_accumulator_buffer
    end interface
    public accumulator_buffer

    !> Clear the accumulator of all observations and reset all statistical
    !! aggregates.
    interface accumulator_reset
        module procedure p_accumulator_reset
    end interface
    public accumulator_reset

    !> Free all memory associated with the accumulator.
    interface accumulator_delete
        module procedure p_accumulator_delete
    end interface
    public accumulator_delete

    !> Return the number of components in the random vector.
    interface accumulator_num_comp
        module procedure p_accumulator_num_comp
    end interface
    public accumulator_num_comp

    !> Return the number of blocks in the variance stack
    interface accumulator_num_blocks
        module procedure p_accumulator_num_blocks
    end interface
    public accumulator_num_blocks

    !> Return whether this accumulator tracks the mean
    interface accumulator_has_mean
        module procedure p_accumulator_has_mean
    end interface
    public accumulator_has_mean

    !> Return whether this accumulator tracks a stack of variances
    interface accumulator_has_blocks
        module procedure p_accumulator_has_blocks
    end interface
    public accumulator_has_blocks

    !> Return number of observations in the accumulator
    interface accumulator_count
       module procedure p_accumulator_count
    end interface
    public accumulator_count

    !>      call accumulator_mean(acc, mean)
    !!
    !! Copy the current sample mean to `mean`.  If the mean is not tracked,
    !! instead fill the buffer with NaNs.
    interface accumulator_mean
        module procedure p_accumulator_mean
    end interface
    public accumulator_mean

    !>      call accumulator_blocks(acc, blocks)
    !!
    !! Copy the stack of squared differences from the mean to blocks.
    !! If the blocks are not tracked, instead fill the buffer with NaNs.
    interface accumulator_blocks
        module procedure p_accumulator_blocks
    end interface
    public accumulator_blocks

contains

    ! ######## METHODS FOR ANY ZAccumulator ########

    subroutine p_accumulator_init(this, typ, ncomp, nlevels)
        type(ZAccumulator), intent(inout) :: this
        integer, intent(in) :: typ
        integer(c_int64_t), intent(in) :: ncomp
        integer(c_int64_t), intent(in), optional :: nlevels

        if (ncomp < 0) &
            error stop 'Number of components must be non-negative'
        if (present(nlevels)) then
            if (nlevels < 0) &
                error stop 'Number of variance levels must be non-negative'
        endif

        this%ncomp = ncomp
        if (typ == ACC_MEAN) then
            allocate(this%buffer(ncomp))
        elseif (typ == ACC_BLOCKS) then
            if (.not. present(nlevels)) &
                error stop 'Must give number of levels'
            allocate(this%buffer(ncomp))
            allocate(this%dat(ncomp, nlevels))
        elseif (typ /= ACC_NULL) then
            error stop 'Invalid type of accumulator'
        endif
        call accumulator_reset(this)
    end subroutine

    subroutine p_accumulator_reset(this)
        type(ZAccumulator), intent(inout) :: this

        this%n = 0
        if (allocated(this%buffer)) then
            this%buffer(:) = 0
        endif
        if (allocated(this%dat)) then
            this%dat(:,:)%spill = 0
            this%dat(:,:)%mean = 0
            this%dat(:,:)%sqdiff = 0
        endif
    end subroutine

    subroutine p_accumulator_buffer(this, buf)
        type(ZAccumulator), intent(inout), target :: this
        complex(c_double_complex), intent(out), pointer :: buf(:)

        buf => this%buffer
    end subroutine

    subroutine p_accumulator_delete(this)
        type(ZAccumulator), intent(inout) :: this

        ! XXX we probably do not actually need this
        if (allocated(this%buffer)) &
            deallocate(this%buffer)
        if (allocated(this%dat)) &
            deallocate(this%dat)
    end subroutine

    subroutine p_accumulator_add(this)
        type(ZAccumulator), intent(inout) :: this

        if (allocated(this%dat)) &
            call autocorracc_add(this)

        this%n = this%n + 1
    end subroutine

    function p_accumulator_num_comp(this) result(answer)
        type(ZAccumulator), intent(in) :: this
        integer(c_int64_t) :: answer

        answer = this%ncomp
    end function

    function p_accumulator_num_blocks(this) result(answer)
        type(ZAccumulator), intent(in) :: this
        integer(c_int64_t) :: answer

        if (allocated(this%dat)) then
            answer = size(this%dat, 2)
        else
            answer = 0
        endif
    end function

    function p_accumulator_has_mean(this) result(answer)
        type(ZAccumulator), intent(in) :: this
        logical :: answer

        answer = allocated(this%buffer)
    end function

    function p_accumulator_has_blocks(this) result(answer)
        type(ZAccumulator), intent(in) :: this
        logical :: answer

        answer = allocated(this%dat)
    end function

    function p_accumulator_count(this) result(n)
        type(ZAccumulator), intent(in) :: this
        integer(c_int64_t) :: n

        n = this%n
    end function

    subroutine p_accumulator_mean(this, out_)
        type(ZAccumulator), intent(in) :: this
        complex(c_double_complex), intent(out) :: out_(:)

        if (allocated(this%dat)) then
            call autocorracc_mean(this, out_)
        else if (allocated(this%buffer)) then
            call meanacc_mean(this, out_)
        else
            out_(:) = nan(1.0d0)
        endif
    end subroutine

    subroutine p_accumulator_blocks(this, out_)
        type(ZAccumulator), intent(in) :: this
        real(c_double), intent(out) :: out_(:,:)

        if (allocated(this%dat)) then
            call autocorracc_blocks(this, out_)
        else
            out_(:,:) = nan(1.0d0)
        endif
    end subroutine

    ! ######## METHODS FOR MEAN ZAccumulator ########

    subroutine meanacc_mean(this, out_)
        type(ZAccumulator), intent(in) :: this
        complex(c_double_complex), intent(out) :: out_(:)

        if (size(out_) /= size(this%buffer)) &
            stop '[meanacc_mean] Invalid size of out_ array'

        out_(:) = this%buffer(:) / this%n
    end subroutine

    ! ######## METHODS FOR AUTOCORRELATION ZAccumulator ########

    subroutine autocorracc_add(this)
        type(ZAccumulator), intent(inout) :: this

        integer :: lvl
        integer(c_int64_t) :: n, i
        complex(c_double_complex) :: val_i

        n = this%n
        lvl = 1

        ! Handle level 0 first using Welford, West, Hanson update formula
        ! NOTE: we use a do loop here rather than vectorized notation, because
        !       otherwise ifort cannot work out aliasing and starts creating
        !       temporaries.
        do i = 1, size(this%dat, 1)
            call welford_add(this%dat(i, 1), this%buffer(i), n)
        end do

        ! Whenever the lowest n bits are all ones, we need to roll over results
        ! to the n'th level.  See arxiv:1810.05079, Sec III.D for details
        do while(iand(n, 1_c_int64_t) /= 0)
            if (lvl == size(this%dat, 2)) exit
            n = n / 2
            lvl = lvl + 1

            ! add value of lower-level bin to current level
            do i = 1, size(this%dat, 1)
                ! First, empty lower level
                val_i = this%dat(i,lvl-1)%spill / 2
                this%dat(i, lvl-1)%spill = 0

                ! Add to current level
                call welford_add(this%dat(i, lvl), val_i, n)
            end do
        end do

        this%buffer(:) = 0
    end subroutine autocorracc_add

    pure subroutine welford_add(atom, val, n)
        type(varatom), intent(inout) :: atom
        complex(c_double_complex), intent(in) :: val
        integer(c_int64_t), intent(in) :: n
        complex(c_double_complex) :: incr1, incr2

        ! Welford, West, Hanson update formula
        atom%spill = atom%spill + val
        incr1 = val - atom%mean
        atom%mean = atom%mean + incr1 / (n + 1)
        incr2 = val - atom%mean
        atom%sqdiff = atom%sqdiff + real(conjg(incr1) * incr2)
    end subroutine

    subroutine autocorracc_mean(this, out_)
        type(ZAccumulator), intent(in) :: this
        complex(c_double_complex), intent(out) :: out_(:)

        if (size(out_) /= size(this%dat, 1)) &
            error stop '[autocorracc_mean] Invalid size of out_ array'

        out_(:) = this%dat(:,1)%mean
    end subroutine autocorracc_mean

    subroutine autocorracc_blocks(this, out_)
        type(ZAccumulator), intent(in) :: this
        real(c_double), intent(out) :: out_(:,:)

        integer(c_int64_t) :: n
        integer :: level

        if (size(out_,1) /= size(this%dat,1)) &
            error stop '[autocorracc_mean] Invalid size of out_ array'

        n = this%n
        do level = 1, min(size(this%dat, 2), size(out_, 2))
            if (n > 1) then
                out_(:,level) = this%dat(:,level)%sqdiff / (n - 1)
            else
                out_(:,level) = this%dat(:,level)%sqdiff / 0.
            endif
            n = n / 2
        end do
    end subroutine
end module
