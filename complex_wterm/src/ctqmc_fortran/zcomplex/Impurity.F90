! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.

!> This module stores the information about the impurity cumulant.
module MImpurityZ
    use iso_c_binding, only: c_double, c_double_complex
    use MBufferI
    use MCommon
    use MExtRange
    use ZMOperator
    use MPsiZ
    use MLocalBase
    use MPermutation
    use MPrinting
    use MSorting
    use Testing
    implicit none
    private

    public :: TLocalOper

    !> Type for storing a "kink" in an impurity cumulant
    type :: impurity_pos
        !> Specification of the impurity operator sitting at that position
        type(TLocalOper) :: spec

        !> ket state obtained by applying all operators from the pivot position
        !! onward up to and including the current operator to the currently
        !! selected eigenstate.
        type(ZTKet) :: after

        !> bra state obtained by applying all operators before the pivot
        !! position back, wrapping around the trace, and the finally up to and
        !! including the current operator.
        type(ZTBra) :: before
    end type

    type, public :: ZImpurity
        private
        real(c_double) :: beta = -1
        type(ZOperEigen) :: hloc
        type(ZTPsis) :: psis

        type(ZExtRange) :: weight
        integer :: size = 0
        type(impurity_pos), allocatable :: pos(:)
        integer :: pivot

        integer :: nallowed
        integer, allocatable :: allowed_outer(:)
        integer :: outer_sst
    end type

    type, abstract, public :: ZImpurityUpdateBase
        private
        type(ZImpurity), pointer :: target
        type(ZExtRange) :: weight

        integer :: outer_sst
    contains
        private
        procedure(base_accept_update), deferred :: accept_update
    end type

    abstract interface
        subroutine base_accept_update(self)
            import :: ZImpurityUpdateBase
            class(ZImpurityUpdateBase), intent(inout) :: self
        end
    end interface

    type, extends(ZImpurityUpdateBase), public :: ZImpurityReplace
        private
        integer :: size
        type(impurity_pos), allocatable :: pos(:)
        type(ZTKet) :: ket_work
        type(ZTBra) :: bra_work

        integer :: nallowed
        integer, allocatable :: allowed_outer(:)
    contains
        private
        procedure, non_overridable :: accept_update => p_repl_accept
    end type

    type, abstract, extends(ZImpurityUpdateBase) :: naive_update
        private
        type(ZImpurityReplace) :: naive
    contains
        private
        procedure :: accept_update => p_naive_accept
    end type

    type, extends(ZImpurityUpdateBase), public :: ZImpurityGrow
        private
        integer :: new_size, rank

        !> Growth permutation: `j = perm(i)` means the `i`-th operator in the
        !! current configuration will become the `j`-th operator in the updated
        !! configuration.
        integer, allocatable :: perm(:)

        !> Position of new operators in the updated configuration, where
        !! inspos(i) corresponds to the i'th added operator in the proposal
        integer, allocatable :: inspos(:)

        !> Position of the new operators in the updated configuration, where
        !! the operators have been sorted by insertion index, i.e., time
        !! while preserving order of equal-time operators.
        integer, allocatable :: inspos_ord(:)

        !> Updated positions in the impurity: pos(i) will become target%pos(i)
        !! if an update is neccessary, and will be left alone otherwise.
        type(impurity_pos), allocatable :: pos(:)

        !> The range of new positions which encloses the operator changes,
        !! i.e., changes to the trace are enclosed in pos(istart:iend)
        integer :: istart, iend
        logical :: start_front, end_back

        !> Work arrays
        type(ZTKet) :: work_ket
        type(ZTBra) :: work_bra
        type(ZImpurityReplace) :: naive
    contains
        private
        procedure, non_overridable :: accept_update => grow_accept
    end type

    type, extends(ZImpurityUpdateBase), public :: ZImpurityShrink
        private
        integer :: new_size, rank

        !> Shrink permutation: `j = perm(i)` means the `i`-th operator in the
        !! current configuration will become the `j`-th operator in the
        !! updated configuration.
        integer, allocatable :: perm(:)

        !> Position of removed operators in the updated configuration, where
        !! irem(i) corresponds to the i'th removed operator in the proposal
        !! in order of ascending time
        integer, allocatable :: irem(:)

        !> Updated positions in the impurity: pos(i) will become target%pos(i)
        !! if an update is neccessary, and will be left alone otherwise.
        type(impurity_pos), allocatable :: pos(:)

        !> The range of new positions which encloses the operator changes,
        !! i.e., changes to the trace are enclosed in pos(istart:iend)
        integer :: istart, iend
        logical :: start_front, end_back, all_front, all_back

        !> Work arrays
        type(ZTKet) :: work_ket
        type(ZTBra) :: work_bra
        type(ZImpurityReplace) :: naive
    contains
        private
        procedure, non_overridable :: accept_update => shrink_accept
    end type

    type, extends(naive_update), public :: ZImpurityShift
        private
        integer :: new_first
        integer, allocatable :: perm(:)
        real(c_double) :: delta_tau
    end type

    type, extends(naive_update), public :: ZImpurityUpdate
        private
        integer :: rank
        integer, allocatable :: perm(:), remidx(:), inspos(:)
    end type

    !> Initialize impurity with Hamiltonian and inverse temperature
    interface init_impurity
        module procedure p_init_impurity
    end interface
    public init_impurity

    !> Set impurity to given set of operators and outer state
    interface set_impurity
        module procedure p_set_impurity
    end interface
    public set_impurity

    !> Clear impurity of operators and set to outer state
    interface clear_impurity
        module procedure :: p_clear_impurity
    end interface
    public clear_impurity

    !> Return inverse temperature
    interface get_beta
        module procedure p_get_beta
    end interface
    public get_beta

    !> Return relative weight of each superstate in an empty impurity.
    interface thermal_weights
       module procedure p_thermal_weights
    end interface
    public thermal_weights

    !> Return number of operators in impurity cumulant
    interface size
        module procedure p_size
    end interface
    public size

    !> Return total number of orbitals in the impurity
    interface get_nbands
        module procedure p_get_nbands
    end interface
    public get_nbands

    !> Return set of operators of impurity or move
    interface get_operators
        module procedure p_get_operators
        module procedure p_repl_get_operators, p_naive_get_operators
        module procedure grow_get_operators, shrink_get_operators
    end interface
    public get_operators

    !> Return outer superstate currently chosen for the impurity
    interface get_outerbl
        module procedure p_get_outerbl
    end interface
    public get_outerbl

    !> Return superstate in the impurity just before the given time
    interface sst_at_time
        module procedure p_sst_at_time
    end interface
    public sst_at_time

    !> Check invariants in the impurity
    interface verify_impurity
        module procedure p_verify_impurity
    end interface
    public verify_impurity

    !> Return impurity weight (trace of the local cumulant)
    interface get_weight
        module procedure p_get_weight
    end interface
    public get_weight

    !> Compute many-body density matrix
    interface compute_density_matrix
        module procedure p_compute_density_matrix
    end interface
    public compute_density_matrix

    !> Write out information about the impurity
    interface dump
        module procedure p_dump
    end interface
    public dump

    !> Set of outer states for operators which do not violate quantum numbers
    interface allowed_outer_states
        module procedure p_allowed_outer_states, p_repl_allowed_outer_states
    end interface
    public allowed_outer_states

    !> Check if the given outer state is allowed
    interface is_allowed_outer_state
       module procedure p_is_allowed_outer_state, p_repl_is_allowed_outer
    end interface
    public is_allowed_outer_state

    !> Initialize update to replace all operators in the impurity
    interface init_replace_impurity
        module procedure p_init_replace_impurity
    end interface
    public init_replace_impurity

    !> Initialize update to add operators to the impurity
    interface init_grow_impurity
        module procedure p_init_grow_impurity
    end interface
    public init_grow_impurity

    !> Initialize update to remove operators from the impurity
    interface init_shrink_impurity
        module procedure p_init_shrink_impurity
    end interface
    public init_shrink_impurity

    !> Initialize update to cyclically shift the time of impurity operators
    interface init_shift_impurity
        module procedure p_init_shift_impurity
    end interface
    public init_shift_impurity

    !> Initialize update to replace impurity operators with others
    interface init_update_impurity
        module procedure p_init_update_impurity
    end interface
    public init_update_impurity

    !> Propose a completely new set of operators for the impurity
    interface propose_replace_impurity
        module procedure p_propose_replace_impurity
    end interface
    public propose_replace_impurity

    !> Propose operators for insertion into the impurity
    interface propose_grow_impurity
        module procedure p_propose_grow_impurity
    end interface
    public propose_grow_impurity

    !> Propose operators positions for removal from the impurity
    interface propose_shrink_impurity
        module procedure p_propose_shrink_impurity
    end interface
    public propose_shrink_impurity

    !> Propose cyclically shifting the time of all operators
    interface propose_shift_impurity
        module procedure p_propose_shift_impurity
    end interface
    public propose_shift_impurity

    !> Return number of operators shifted across zero.
    interface get_num_wrapped_ops
        module procedure p_get_num_wrapped_ops
    end interface
    public get_num_wrapped_ops

    !> Propose a permutation of spin-orbitals for the impurity operators
    interface propose_permute_impurity_flavours
        module procedure p_propose_permute_impurity_flavours
    end interface
    public propose_permute_impurity_flavours

    !> Propose a set of indices of operators to be replaced by new ones
    interface propose_update_impurity
        module procedure p_propose_update_impurity
    end interface
    public propose_update_impurity

    !> Choose the outer state for type of proposal
    !!
    !!  - an "inner proposal" is one where the outer state is kept the same
    !!  - an "outer proposal" in one where the outer state is updated.
    interface choose_matching_outer_state
        module procedure grow_choose_matching_outer_state
        module procedure shrink_choose_matching_outer_state
        module procedure update_choose_matching_outer_state
    end interface
    public choose_matching_outer_state

    !> Choose outer state of the move
    interface choose_outer_state
        module procedure p_repl_choose, p_naive_choose
    end interface
    public choose_outer_state

    !> Compute weight of the updated configuration
    interface compute_weight
        module procedure repl_compute_weight, naive_compute_weight
        module procedure grow_compute_weight, shrink_compute_weight
    end interface
    public compute_weight

    !> Return false if one is barred from calling accept_update() on the move
    interface is_update_allowed
        module procedure p_is_update_allowed
    end interface
    public is_update_allowed

    !> Return ratio of new to old weight if the move is to be accepted
    interface weight_ratio
        module procedure p_weight_ratio
    end interface
    public weight_ratio

    !> Accept the update
    interface accept_update
        module procedure p_accept_update
    end interface
    public accept_update

    !> Swap type of two operators, allowing them to trade the worm state
    interface swap_operator_types
        module procedure p_swap_operator_types
    end interface
    public swap_operator_types

    interface get_newidx_addorder
        module procedure p_grow_get_newidx_addorder, p_update_get_newidx_addorder
    end interface
    public get_newidx_addorder

    integer, parameter :: OUTER_NOT_SELECTED = -2
    complex(c_double_complex), parameter :: ZERO = 0, ONE = 1

    logical :: debug_validate_grow_move = .false.
    logical :: debug_validate_shrink_move = .false.

contains

    subroutine p_init_impurity(self, beta, hloc, psis, outer_sst)
        type(ZImpurity), intent(out) :: self
        real(c_double), intent(in) :: beta
        type(ZOperEigen), intent(in) :: hloc
        type(ZTPsis), intent(in) :: psis
        integer, intent(in) :: outer_sst

        self%beta = beta
        self%hloc = hloc
        self%psis = psis

        if (allocated(self%allowed_outer)) &
            deallocate(self%allowed_outer)
        allocate(self%allowed_outer(get_num_superstates(self%hloc)))
        call reserve_pos(self%pos, 1)
        call set_to_empty(self, outer_sst)
    end

    ! XXX merge with clear_impurity
    subroutine set_to_empty(self, outer_sst)
        type(ZImpurity), intent(inout) :: self
        integer, intent(in) :: outer_sst

        self%size = 0
        call start_sst_list(self%hloc, self%allowed_outer, self%nallowed)
        self%outer_sst = outer_sst
        self%weight = partition_function(self%hloc, self%beta, outer_sst)
    end

    subroutine check_init(self)
        type(ZImpurity), intent(in) :: self

        if (.not. allocated(self%pos)) &
            error stop 'IMPURITY is not initialized'
    end

    subroutine p_set_impurity(self, ops, outer_sst)
        type(ZImpurity), intent(inout), target :: self
        type(TLocalOper), intent(in) :: ops(:)
        integer, intent(in) :: outer_sst
        type(ZImpurityReplace) :: move

        call init_replace_impurity(move, self)
        call propose_replace_impurity(move, ops, outer_sst)
        if (.not. is_update_allowed(move)) &
            error stop 'Cannot set impurity to illegal state'

        call compute_weight(move)
        if (weight_ratio(move) == 0) &
            write (0,*) 'WARNING: setting impurity to state with zero weight'
        call accept_update(move)
    end

    subroutine p_clear_impurity(self, outer_sst)
        type(ZImpurity), intent(inout), target :: self
        integer, intent(in) :: outer_sst
        type(TLocalOper) :: ops(0)

        call set_impurity(self, ops, outer_sst)
    end

    pure function p_get_beta(self) result(r)
        type(ZImpurity), intent(in) :: self
        real(c_double) :: r
        r = self%beta
    end

    pure function p_size(self) result(r)
        type(ZImpurity), intent(in) :: self
        integer :: r
        r = self%size
    end

    pure function p_get_nbands(self) result(r)
        type(ZImpurity), intent(in) :: self
        integer :: r
        r = size(self%psis%psis, 1)
    end

    pure function p_get_weight(self) result(r)
        type(ZImpurity), intent(in) :: self
        type(ZExtRange) :: r
        r = self%weight
    end

    function p_get_operators(self) result(ops)
        type(ZImpurity), intent(in) :: self
        type(TLocalOper), allocatable :: ops(:)
        integer :: i

        allocate(ops(self%size))
        do i = 1, self%size
            ops(i) = self%pos(i)%spec
        enddo
    end function

    function p_get_outerbl(self) result(bl)
        type(ZImpurity), intent(in) :: self
        integer :: bl
        bl = self%outer_sst
    end

    subroutine fill_allowed_outer(self)
        type(ZImpurity), intent(inout) :: self
        integer :: i

        call start_sst_list(self%hloc, self%allowed_outer, self%nallowed)
        do i = 1, self%size
            call connecting_sst_list( &
                    get_psi_for_localoper(self%psis, self%pos(i)%spec), &
                    self%allowed_outer, self%nallowed)
        enddo
        call finish_sst_list(self%hloc, self%allowed_outer, self%nallowed)
    end

    subroutine p_verify_impurity(self, rtol)
        type(ZImpurity), intent(in) :: self
        real(c_double), intent(in) :: rtol
        integer :: i, nallowed
        integer, allocatable :: allowed(:)
        real(c_double) :: delta_tau
        type(ZTKet) :: work
        type(ZExtRange) :: tr

        if (.not. (self%beta > 0 .and. self%beta <= HUGE(self%beta))) &
            error stop 'Invalid inverse temperature'

        call assert_equal(allocated(self%pos), .true.)
        call assert_equal(allocated(self%allowed_outer), .true.)
        call assert_equal(size(self%allowed_outer), get_num_superstates(self%hloc))

        if (self%size < 0 .or. self%size > size(self%pos)) &
            error stop 'Invalid size'
        if (self%nallowed <= 0 .or. self%nallowed > size(self%allowed_outer)) &
            error stop 'Invalid nallowed'
        if (self%outer_sst < 0 .or. self%outer_sst >= size(self%allowed_outer)) &
            error stop 'Invalid outer sst'

        ! Check operator specifications
        do i = 1, self%size
            call check_oper(self, self%pos(i)%spec)
        enddo

        ! Check allowed outer states
        allocate(allowed(size(self%allowed_outer)))
        call start_sst_list(self%hloc, allowed, nallowed)
        do i = 1, self%size
            call connecting_sst_list( &
                        get_psi_for_localoper(self%psis, self%pos(i)%spec), &
                        allowed, nallowed)
        enddo
        call finish_sst_list(self%hloc, allowed, nallowed)
        call assert_equal(self%allowed_outer(:self%nallowed), allowed(:nallowed))

        ! Check weight
        call assert_close(self%weight, recompute_weight(self), rtol)

        ! Check before/after
        do i = 1, self%size - 1
            delta_tau = self%pos(i + 1)%spec%tau - self%pos(i)%spec%tau
            if (delta_tau < 0) &
                error stop 'Times are not ordered'

            call copy(self%pos(i)%after, work)
            call time_evolve(self%hloc, delta_tau, work)
            call assert_close(braket_dotprod(self%pos(i+1)%before, work), &
                              self%weight, rtol)
        enddo

        ! Check "wrap-around"
        if (self%size > 0) then
            delta_tau = self%beta - self%pos(self%size)%spec%tau
            tr = trace_boltzmann(self%hloc, delta_tau, self%pos(self%size)%after)
            call assert_close(tr, self%weight, rtol)

            delta_tau = self%pos(1)%spec%tau
            tr = trace_boltzmann(self%hloc, delta_tau, self%pos(1)%before)
            call assert_close(tr, self%weight, rtol)
        endif
    end

    function recompute_weight(self) result(weight)
        type(ZImpurity), intent(in) :: self
        type(ZExtRange) :: weight
        type(ZTKet) :: ket, ket2
        type(ZTOperator), pointer :: op
        real(c_double) :: delta_tau
        integer :: i

        if (self%size == 0) then
            weight = partition_function(self%hloc, self%beta, self%outer_sst)
            return
        endif

        op => get_psi_for_localoper(self%psis, self%pos(1)%spec)
        call set_to_operator(ket, op, self%outer_sst)
        do i = 2, self%size
            delta_tau = self%pos(i)%spec%tau - self%pos(i-1)%spec%tau
            call time_evolve(self%hloc, delta_tau, ket)
            op => get_psi_for_localoper(self%psis, self%pos(i)%spec)
            call apply_operator(ket2, op, ket)
            call swap(ket2, ket)
        enddo

        delta_tau = self%beta + self%pos(1)%spec%tau - self%pos(self%size)%spec%tau
        weight = trace_boltzmann(self%hloc, delta_tau, ket)
    end

    function p_thermal_weights(self) result(weights)
        type(ZImpurity), intent(in) :: self
        real(c_double), allocatable :: weights(:)

        weights = thermal_weights(self%hloc, self%beta)
    end function

    function p_allowed_outer_states(self) result(r)
        type(ZImpurity), intent(in), target :: self
        integer, pointer :: r(:)

        call check_init(self)
        r => self%allowed_outer(:self%nallowed)
    end

    logical function p_is_allowed_outer_state(self, sst) result(is_allowed)
        type(ZImpurity), intent(in) :: self
        integer, intent(in) :: sst

        if (sst < 0 .or. sst >= size(self%allowed_outer)) &
            error stop 'Invalid outer state'

        ! XXX we could use bisectioning here
        is_allowed = is_element_of(sst, self%allowed_outer(:self%nallowed))
    end

    pure logical function is_element_of(x, set)
        integer, intent(in) :: x, set(:)
        integer :: i

        is_element_of = .false.
        do i = 1, size(set)
            if (x == set(i)) then
                is_element_of = .true.
                return
            endif
        enddo
    end

    subroutine reserve_pos(buf, cap)
        type(impurity_pos), allocatable, intent(inout) :: buf(:)
        integer, intent(in) :: cap
        type(impurity_pos), allocatable :: tmp(:)
        integer :: i

        if (.not. allocated(buf)) then
            allocate(buf(cap))
        elseif (cap <= size(buf)) then
            continue
        else
            ! Always preserve the elements, because they have preallocated
            ! buffers inside them
            allocate(tmp(cap))
            do i = 1, size(buf)
                call swap_pos(buf(i), tmp(i))
            enddo
            deallocate(buf)
            call move_alloc(tmp, buf)
        endif
    end subroutine

    pure subroutine swap_pos(a, b)
        type(impurity_pos), intent(inout) :: a, b

        call swap(a%spec, b%spec)
        call swap(a%after, b%after)
        call swap(a%before, b%before)
    end

    function get_psi_for_localoper(psis, op) result(psi)
        type(ZTPsis), intent(in), target :: psis
        type(TLocalOper), intent(in) :: op
        type(ZTOperator), pointer :: psi

        psi => psis%psis(op%orb, op%sp, oldtype(op%type))
    end function

    subroutine check_oper(self, op)
        type(ZImpurity), intent(in) :: self
        type(TLocalOper), intent(in) :: op

        if (.not. (op%tau >= 0 .and. op%tau <= self%beta)) &
            error stop 'Invalid time of operator'
        if (.not. (op%orb >= 1 .and. op%orb <= size(self%psis%psis, 1))) &
            error stop 'Invalid orbital of operator'
        if (.not. (op%sp >= 1 .and. op%sp <= size(self%psis%psis, 2))) &
            error stop 'Invalid spin of operator'
        if (oldtype(op%type) <= 0) &
            error stop 'Invalid type of operator'
    end

    subroutine check_opers(self, op)
        type(ZImpurity), intent(in) :: self
        type(TLocalOper), intent(in) :: op(:)
        integer :: i

        do i = 1, size(op)
            call check_oper(self, op(i))
        enddo
    end

    subroutine p_dump(self, unit)
        type(ZImpurity), intent(in) :: self
        integer, intent(in), optional :: unit

        character(len=4), parameter :: spin_str(2) = (/ 'up  ', 'down' /)
        character(len=3), parameter :: type_str(-2:2) = &
                (/ '[-]', ' - ', ' ? ', ' + ', '[+]' /)
        type(TLocalOper), allocatable :: op
        integer :: u, i

        u = default(unit, 0)
        if (.not. allocated(self%pos)) then
            write (u,*) 'Unallocated impurity'
            return
        endif

        write(u,97) get_nbands(self), self%beta
        write(u,"(' * weight = ')",advance="no")
        call dump(self%weight, u)
        write(u,99,advance="no") get_outerbl(self), size(self%allowed_outer)
        call print_array(self%allowed_outer(:self%nallowed), &
                         fmt="I0", name="allowed", file=u)
        write(u,96) self%size
        do i = 1, self%size
            op = self%pos(i)%spec
            write (u, 98) &
                i, op%tau, type_str(op%type), op%orb, spin_str(op%sp), &
                get_sst(self%pos(i)%before), get_sst(self%pos(i)%after)
        enddo

    97  format('Local state for ', I0, ' orbitals at beta = ', ES0.5)
    99  format(' * Current block ', I0, ' out of ', I0, '; ')
    96  format(' * List of ', I0, ' operators:')
    98  format('op(', I3, ') =', F20.10, X, A, X, I3, X, A, 5X, 'sst', I3, ' ->', I3)
    end

    subroutine p_compute_density_matrix(self, sgn, out_op)
        type(ZImpurity), intent(in) :: self
        complex(c_double_complex), intent(in) :: sgn
        type(ZTOperator), intent(inout) :: out_op

        integer :: i
        real(c_double) :: delta_tau
        type(ZExtRange) :: alpha

        ! XXX move work arrays to estimator, once that materializes
        type(ZTKet) :: ket
        type(ZTBra) :: bra
        type(ZTOperator) :: work

        if (.not. is_initialized(out_op)) &
            call init_operator_like(out_op, self%hloc)

        call init_operator_like(work, self%hloc)
        call set_to_identity(ket, self%hloc, self%outer_sst)
        call set_to_identity(bra, self%hloc, self%outer_sst)

        alpha = sgn / self%beta / self%weight

        if (self%size == 0) then
            delta_tau = self%beta
            call outer_integral( &
                    out_op, bra, ket, delta_tau, self%hloc, alpha, work)
            return
        endif

        ! Integral in between all operators
        do i = 1, self%size - 1
            delta_tau = self%pos(i+1)%spec%tau - self%pos(i)%spec%tau
            call outer_integral( &
                    out_op, self%pos(i+1)%before, self%pos(i)%after, &
                    delta_tau, self%hloc, alpha, work)
        enddo

        ! Edges
        delta_tau = self%beta - self%pos(self%size)%spec%tau
        call outer_integral( &
                out_op, bra, self%pos(self%size)%after, &
                delta_tau, self%hloc, alpha, work)

        delta_tau = self%pos(1)%spec%tau
        call outer_integral( &
                out_op, self%pos(1)%before, ket, &
                delta_tau, self%hloc, alpha, work)
    end

    integer function p_sst_at_time(self, tau) result(sst)
        type(ZImpurity), intent(in) :: self
        real(c_double), intent(in) :: tau
        integer :: pos

        if (self%size == 0) then
            sst = self%outer_sst
        else
            pos = position_after_tau(self, tau)
            sst = get_sst(self%pos(pos)%before)
        endif
    end

    integer function position_after_tau(self, tau) result(new_first)
        type(ZImpurity), intent(in) :: self
        real(c_double), value :: tau
        real(c_double) :: curr_tau(self%size)

        ! We have to do this because get_sorted_insert breaks the tie by
        ! giving a position AFTER any operators seated at time, and we want
        ! one before
        tau = NEAREST(tau, -HUGE(tau))
        curr_tau(:) = self%pos(:self%size)%spec%tau
        new_first = get_sorted_insert(curr_tau, tau)
        if (new_first == self%size + 1) &
            new_first = 1
    end

    ! -------------------------------------------------------------------------
    ! BASE MOVE

    subroutine init_update_base(self, t)
        class(ZImpurityUpdateBase), intent(out) :: self
        type(ZImpurity), intent(inout), target :: t

        self%target => t
        self%weight = 0.0d0

        self%outer_sst = OUTER_NOT_SELECTED
    end subroutine

    pure logical function p_is_update_allowed(self) result(test)
        class(ZImpurityUpdateBase), intent(in) :: self

        test = self%outer_sst >= 0
    end

    function p_weight_ratio(self) result(ratio)
        class(ZImpurityUpdateBase), intent(in) :: self
        real(c_double) :: ratio

        ratio = abs(limrange(self%weight / self%target%weight))
    end

    subroutine p_accept_update(self)
        class(ZImpurityUpdateBase), intent(inout) :: self

        call self%accept_update()
    end

    ! =========================================================================
    ! REPLACE MOVE
    ! =========================================================================

    subroutine p_init_replace_impurity(self, t)
        type(ZImpurityReplace), intent(out) :: self
        type(ZImpurity), intent(inout), target :: t

        call init_update_base(self, t)
        self%nallowed = 0
        allocate(self%allowed_outer(size(t%allowed_outer)))
    end subroutine

    subroutine p_propose_replace_impurity(self, op, outer_sst)
        type(ZImpurityReplace), intent(inout) :: self
        type(TLocalOper), intent(in) :: op(:)
        integer, intent(in), optional :: outer_sst
        integer :: i
        real(c_double) :: tau_prev

        if (.not. associated(self%target)) &
            error stop 'Not initialized'

        self%size = size(op)
        call reserve_pos(self%pos, self%size)

        tau_prev = 0
        do i = 1, self%size
            self%pos(i)%spec = op(i)
            call check_oper(self%target, op(i))
            if (.not. (op(i)%tau >= tau_prev .and. op(i)%tau <= self%target%beta)) &
                error stop 'tau must be sorted and in range [0, beta]'
            tau_prev = op(i)%tau
        enddo

        ! Signals to repl_fill_allowed_outer that we still need to fill it
        self%nallowed = -1

        if (present(outer_sst)) then
            call choose_outer_state(self, outer_sst)
        else
            self%outer_sst = OUTER_NOT_SELECTED
        endif
    end

    subroutine repl_fill_allowed_outer(self)
        type(ZImpurityReplace), intent(inout) :: self
        integer :: i

        if (self%nallowed >= 0) &
            return

        call start_sst_list(self%target%hloc, self%allowed_outer, self%nallowed)
        do i = 1, self%size
            call connecting_sst_list( &
                    get_psi_for_localoper(self%target%psis, self%pos(i)%spec), &
                    self%allowed_outer, self%nallowed)
        enddo
        call finish_sst_list(self%target%hloc, self%allowed_outer, self%nallowed)
    end

    function p_repl_get_operators(self) result(ops)
        type(ZImpurityReplace), intent(in) :: self
        type(TLocalOper), allocatable :: ops(:)
        integer :: i

        allocate(ops(self%size))
        do i = 1, self%size
            ops(i) = self%pos(i)%spec
        enddo
    end function

    function p_repl_allowed_outer_states(self) result(r)
        class(ZImpurityReplace), intent(inout), target :: self
        integer, pointer :: r(:)

        call repl_fill_allowed_outer(self)
        r => self%allowed_outer(:self%nallowed)
    end

    logical function p_repl_is_allowed_outer(self, sst) result(is_allowed)
        class(ZImpurityReplace), intent(inout) :: self
        integer, intent(in) :: sst

        if (sst < 0 .or. sst >= size(self%allowed_outer)) &
            error stop 'Invalid outer state'

        ! XXX this is potentially an overkill.
        call repl_fill_allowed_outer(self)

        ! XXX we could use bisectioning here
        is_allowed = is_element_of(sst, self%allowed_outer(:self%nallowed))
    end

    subroutine p_repl_choose(self, outer_sst)
        class(ZImpurityReplace), intent(inout) :: self
        integer, intent(in) :: outer_sst
        integer :: outer_sst_final

        ! First, let's check quantum numbers
        outer_sst_final = final_sst_pos(&
                outer_sst, self%pos(:self%size), self%target%psis)

        if (outer_sst /= outer_sst_final) then
            self%outer_sst = -1
        else
            self%outer_sst = outer_sst
        endif
    end

    subroutine repl_compute_weight(self)
        class(ZImpurityReplace), intent(inout) :: self

        if (self%outer_sst < 0) then
            self%weight = ZERO
            return
        endif

        ! Special case for zero size
        if (self%size == 0) then
            self%weight = partition_function(&
                    self%target%hloc, self%target%beta, self%outer_sst)
            return
        endif

        call first_after(self%target, self%pos(1), self%outer_sst)
        call fill_after(self%target, self%pos(:self%size-1), self%ket_work)

        call last_before(self%target, self%pos(self%size), self%outer_sst)
        self%weight = sandwich( &
                self%target, self%pos(self%size-1:self%size), self%ket_work)
    end

    function final_sst_pos(initial_sst, pos, psi)
        integer, intent(in) :: initial_sst
        type(impurity_pos), intent(in) :: pos(:)
        type(ZTPsis), intent(in) :: psi
        type(ZTOperator), pointer :: op
        integer :: i, final_sst_pos

        final_sst_pos = initial_sst
        do i = 1, size(pos)
            if (final_sst_pos == -1) &
                return
            op => get_psi_for_localoper(psi, pos(i)%spec)
            final_sst_pos = connecting_sst(op, final_sst_pos)
        enddo
    end function

    subroutine first_after(imp, pos, outer_sst)
        type(ZImpurity), intent(in) :: imp
        type(impurity_pos), intent(inout) :: pos
        integer, intent(in) :: outer_sst

        type(ZTOperator), pointer :: op

        op => get_psi_for_localoper(imp%psis, pos%spec)
        call set_to_operator(pos%after, op, outer_sst)
        call relocate_state(imp%hloc, outer_sst, pos%spec%tau, pos%after)
    end

    subroutine fill_after(imp, pos, ket_work)
        type(ZImpurity), intent(in) :: imp
        type(impurity_pos), intent(inout) :: pos(:)
        type(ZTKet), intent(inout) :: ket_work

        type(ZTOperator), pointer :: op
        real(c_double) :: delta_tau
        integer :: i

        do i = 1, size(pos)-1
            delta_tau = pos(i+1)%spec%tau - pos(i)%spec%tau
            op => get_psi_for_localoper(imp%psis, pos(i+1)%spec)
            call copy(pos(i)%after, ket_work)
            call time_evolve(imp%hloc, delta_tau, ket_work)
            call apply_operator(pos(i+1)%after, op, ket_work)
        enddo
    end

    subroutine last_before(imp, pos, outer_sst)
        type(ZImpurity), intent(in) :: imp
        type(impurity_pos), intent(inout) :: pos
        integer, intent(in) :: outer_sst

        type(ZTOperator), pointer :: op

        op => get_psi_for_localoper(imp%psis, pos%spec)
        call set_to_operator(pos%before, op, outer_sst)
        call relocate_state( &
                imp%hloc, outer_sst, imp%beta - pos%spec%tau, pos%before)
    end

    subroutine fill_before(imp, pos, bra_work)
        type(ZImpurity), intent(in) :: imp
        type(impurity_pos), intent(inout) :: pos(:)
        type(ZTBra), intent(inout) :: bra_work

        type(ZTOperator), pointer :: op
        real(c_double) :: delta_tau
        integer :: i

        do i = size(pos) - 1, 1, -1
            delta_tau = pos(i+1)%spec%tau - pos(i)%spec%tau
            op => get_psi_for_localoper(imp%psis, pos(i)%spec)
            call copy(pos(i+1)%before, bra_work)
            call time_evolve(imp%hloc, delta_tau, bra_work)
            call apply_adjoint(pos(i)%before, op, bra_work)
        enddo
    end subroutine

    function sandwich(imp, pos, work) result(r)
        type(ZImpurity), intent(in) :: imp
        type(impurity_pos), intent(in) :: pos(2)
        type(ZTKet), intent(inout) :: work
        type(ZExtRange) :: r
        real(c_double) :: delta_tau

        ! Bridge the gap of the last time evolution
        call copy(pos(1)%after, work)
        delta_tau = pos(2)%spec%tau - pos(1)%spec%tau
        call time_evolve(imp%hloc, delta_tau, work)

        ! Compute the dot product
        r = braket_dotprod(pos(2)%before, work)
    end

    subroutine p_repl_accept(self)
        class(ZImpurityReplace), intent(inout) :: self

        if (self%outer_sst < 0) &
            error stop 'Not an allowed move'

        if (self%size == 0) then
            call set_to_empty(self%target, self%outer_sst)
            return
        endif

        call fill_after( &
                self%target, self%pos(self%size-1:self%size), self%ket_work)
        call fill_before(self%target, self%pos(:self%size), self%bra_work)
        self%target%weight = self%weight
        self%target%size = self%size

        call swap_pos_array(self%target%pos, self%pos)
        self%target%outer_sst = self%outer_sst

        call fill_allowed_outer(self%target)
        !call verify_impurity(self%target, 1d-5)
    end

    subroutine swap_pos_array(a, b)
        type(impurity_pos), allocatable, intent(inout) :: a(:), b(:)
        type(impurity_pos), allocatable :: tmp(:)

        call move_alloc(a, tmp)
        call move_alloc(b, a)
        call move_alloc(tmp, b)
    end

    subroutine p_swap_operator_types(self, idx1, idx2)
        type(ZImpurity), intent(inout) :: self
        integer, intent(in) :: idx1, idx2

        if (idx1 < 1 .or. idx1 > self%size) &
            error stop 'Invalid index 1'
        if (idx2 < 1 .or. idx2 > self%size) &
            error stop 'Invalid index 2'
        if (.not. are_locally_identical_types( &
                    self%pos(idx1)%spec%type, self%pos(idx2)%spec%type)) &
            error stop 'Types are not locally identical'

        call swap(self%pos(idx1)%spec%type, self%pos(idx2)%spec%type)
    end subroutine

    pure logical function are_locally_identical_types(t1, t2)
        integer, intent(in) :: t1, t2

        are_locally_identical_types = &
            (t1 == OpCrea  .and. t2 == OpCreaW) .or. &
            (t1 == OpCreaW .and. t2 == OpCrea) .or. &
            (t1 == OpAnnh  .and. t2 == OpAnnhW) .or. &
            (t1 == OpAnnhW .and. t2 == OpAnnh)
    end function

    ! -------------------------------------------------------------------------
    ! PERMUTATION OF FLAVOURS MOVE (SUBSET OF REPLACE)

    subroutine p_propose_permute_impurity_flavours( &
                    self, ca_perm, flavour_perm, outer_sst)
        type(ZImpurityReplace), intent(inout) :: self
        logical, intent(in) :: ca_perm
        integer, intent(in) :: flavour_perm(:)
        integer, intent(in), optional :: outer_sst

        type(TLocalOper) :: ops_new(self%target%size)
        integer :: old_flavour, new_flavour, nbands, i

        if (size(flavour_perm) /= 2 * get_nbands(self%target)) &
            error stop 'flavour_perm has wrong size'
        if (.not. is_permutation(flavour_perm)) &
            error stop 'flavour_perm is not a permutation'

        nbands = size(flavour_perm) / 2

        do i = 1, self%target%size
            ops_new(i) = self%target%pos(i)%spec

            old_flavour = (ops_new(i)%sp - 1) * nbands + ops_new(i)%orb
            new_flavour = flavour_perm(old_flavour)
            ops_new(i)%orb = mod(new_flavour - 1, nbands) + 1
            ops_new(i)%sp  = (new_flavour - 1) / nbands + 1
            if (ca_perm) &
                ops_new(i)%type = invtype(ops_new(i)%type)
        end do

        call propose_replace_impurity(self, ops_new, outer_sst)
    end

    ! -------------------------------------------------------------------------
    ! NAIVE MOVE

    subroutine p_naive_accept(self)
        class(naive_update), intent(inout) :: self

        call self%naive%accept_update()
    end

    subroutine p_naive_choose(self, outer_sst)
        class(naive_update), intent(inout) :: self
        integer, intent(in) :: outer_sst

        call choose_outer_state(self%naive, outer_sst)
        self%outer_sst = self%naive%outer_sst
    end

    function p_naive_get_operators(self) result(ops)
        class(naive_update), intent(in) :: self
        type(TLocalOper), allocatable :: ops(:)

        allocate(ops, source=get_operators(self%naive))
    end function

    subroutine naive_compute_weight(self)
        class(naive_update), intent(inout) :: self

        call repl_compute_weight(self%naive)
        self%weight = self%naive%weight
    end

    ! =========================================================================
    ! GROW MOVE
    ! =========================================================================

    subroutine p_init_grow_impurity(self, t)
        type(ZImpurityGrow), intent(out) :: self
        type(ZImpurity), intent(inout), target :: t

        call init_update_base(self, t)
        call init_replace_impurity(self%naive, t)
    end subroutine

    subroutine p_propose_grow_impurity(self, ops, outer_sst)
        type(ZImpurityGrow), intent(inout) :: self
        type(TLocalOper), intent(in) :: ops(:)
        integer, intent(in), optional :: outer_sst

        real(c_double) :: old_tau(self%target%size), instau(size(ops))
        type(TLocalOper), allocatable :: ops_new(:)
        integer :: i, isrc, tau_perm(size(ops))

        ! Check and prepare move
        call check_opers(self%target, ops)
        call grow_resize(self, self%target%size + size(ops), size(ops))

        ! Determine positions of the new operators in the new configuration
        ! and associated permutation
        old_tau(:) = self%target%pos(:self%target%size)%spec%tau
        instau(:) = ops(:)%tau
        call sorted_insert(old_tau, instau, self%inspos(:self%rank))
        call grow_perm(self%target%size, self%inspos(:self%rank), &
                       self%perm(:self%new_size))

        ! Copy over operator specifications to the correct positions
        do i = 1, self%new_size
            isrc = self%perm(i)
            if (isrc > self%target%size) then
                self%pos(i)%spec = ops(isrc - self%target%size)
            else
                self%pos(i)%spec = self%target%pos(isrc)%spec
            endif
        enddo

        ! Positions in the new configuration ordered by time (this simplifies
        ! the computation of where the recomputation range starts and stops).
        call sort_perm(instau, tau_perm)
        self%inspos_ord(:self%rank) = self%inspos(tau_perm)

        ! Initialize outer sst to invalid one.
        self%outer_sst = -1
        self%weight = ZERO

        ! Use debug move
        if (debug_validate_grow_move) then
            ops_new = self%pos(:self%new_size)%spec
            call propose_replace_impurity(self%naive, ops_new)
        endif
    end

    subroutine grow_resize(self, new_size, rank)
        type(ZImpurityGrow), intent(inout) :: self
        integer, intent(in) :: new_size, rank

        self%rank = rank
        self%new_size = new_size
        call reserve(self%inspos, rank)
        call reserve(self%inspos_ord, rank)
        call reserve(self%perm, new_size)
        call reserve_pos(self%pos, new_size)
    end

    subroutine grow_choose_matching_outer_state(self, outer)
        type(ZImpurityGrow), intent(inout) :: self
        logical, intent(in) :: outer

        if (outer) then
            call grow_outer_proposal(self)
        else
            call grow_inner_proposal(self)
        endif
    end

    subroutine grow_inner_proposal(self)
        type(ZImpurityGrow), intent(inout) :: self
        type(ZTOperator), pointer :: op
        integer :: sst, sst_front, sst_back, istart_old, iend_old

        if (debug_validate_grow_move) then
            call choose_outer_state(self%naive, self%target%outer_sst)
        endif

        ! An inner proposal is defined as one that leaves the outer sst
        ! invariant. As such, it touches only operators within the span of
        ! the inserted operators
        self%outer_sst = self%target%outer_sst

        ! Figure out where the first new operator lies
        self%start_front = self%inspos_ord(1) == 1
        if (self%start_front) then
            self%istart = 1
            istart_old = -1
            op => get_psi_for_localoper(self%target%psis, self%pos(1)%spec)
            sst_front = connecting_sst(op, self%outer_sst)
        else
            self%istart = self%inspos_ord(1) - 1
            istart_old = self%perm(self%istart)
            sst_front = get_sst(self%target%pos(istart_old)%after)
        endif

        ! Figure out where the last new operator lies
        self%end_back = self%inspos_ord(self%rank) == self%new_size
        if (self%end_back) then
            self%iend = self%new_size
            iend_old = -1
            op => get_psi_for_localoper( &
                        self%target%psis, self%pos(self%new_size)%spec)
            sst_back = connecting_sst_backwards(op, self%outer_sst)
        else
            self%iend = self%inspos_ord(self%rank) + 1
            iend_old = self%perm(self%iend)
            sst_back = get_sst(self%target%pos(iend_old)%before)
        endif

        ! First, check quantum numbers
        sst = final_sst_pos( &
                    sst_front, self%pos(self%istart+1:self%iend-1), &
                    self%target%psis)
        if (sst_back == -1 .or. sst /= sst_back) then
            self%weight = ZERO
            self%outer_sst = -1
        endif

        if (self%outer_sst < 0 .and. debug_validate_grow_move) &
            call assert_close(self%weight, self%naive%weight)
    end

    subroutine grow_outer_proposal(self)
        type(ZImpurityGrow), intent(inout) :: self
        real(c_double) :: bunch_tau
        integer :: istart, isst, isst_old, sst_start, sst_match, sst_naive

        if (debug_validate_grow_move) then
            sst_naive = grow_outer_state_for_outer_proposal(self)
            call choose_outer_state(self%naive, sst_naive)
        endif

        ! An outer proposal is defined as one which leaves the sst at the time
        ! just before the latest inserted operator invariant, e.g., suppose
        ! operators are inserted at times (0, 0.2, 0.5, 0.5), then the sst just
        ! before tau=0.5 should be the same in old and updated configuration.
        ! First, we determine where that point in the new configuration shall
        ! lie:
        bunch_tau = self%pos(self%inspos_ord(self%rank))%spec%tau
        do istart = self%inspos_ord(self%rank) - 1, 1, -1
            if (self%pos(istart)%spec%tau /= bunch_tau) &
                exit
        enddo
        if (istart == 0) &
            error stop 'All operators are inserted at the same time'

        ! In order to determine the sst, we have to figure out the first
        ! operator which is not one to be inserted. If none such is found,
        ! then we are at the beginning and use the outer sst, otherwise
        ! we use the one of the operator to be found.
        do isst = istart, 1, -1
            if (self%perm(isst) <= self%target%size) &
                exit
        enddo
        if (isst == 0) then
            isst_old = -1
            sst_start = self%target%outer_sst
        else
            isst_old = self%perm(isst)
            sst_start = get_sst(self%target%pos(isst_old)%after)
        endif

        ! In order to figure out the outer sst, we move the sst through
        ! the sequence of operators until the end
        self%outer_sst = final_sst_pos( &
                sst_start, self%pos(istart+1:self%new_size), self%target%psis)

        if (debug_validate_grow_move) then
            call assert_equal(self%outer_sst, sst_naive)
        endif

        ! Now, check quantum numbers: this has to be done from the beginning
        ! to position isst, then we have to match the sst
        sst_match = final_sst_pos( &
                        self%outer_sst, self%pos(:istart), self%target%psis)

        if (sst_match /= sst_start) then
            self%weight = ZERO
            self%outer_sst = -1
        endif

        self%istart = 1
        self%iend = self%new_size
        self%start_front = .true.
        self%end_back = .true.

        if (self%outer_sst < 0 .and. debug_validate_grow_move) &
            call assert_close(self%weight, self%naive%weight)
    end

    subroutine grow_compute_weight(self)
        type(ZImpurityGrow), intent(inout) :: self
        integer :: istart_old, iend_old

        ! In these cases we have to initialize new starting vectors for the
        ! forward and/or backward evaluation
        if (self%start_front) then
            call first_after(self%target, self%pos(self%istart), self%outer_sst)
        else
            istart_old = self%perm(self%istart)
            call copy(self%target%pos(istart_old)%after, &
                      self%pos(self%istart)%after)
        endif
        if (self%end_back) then
            call last_before(self%target, self%pos(self%iend), self%outer_sst)
        else
            iend_old = self%perm(self%iend)
            call copy(self%target%pos(iend_old)%before, &
                      self%pos(self%iend)%before)
        endif

        ! Compute forward path between the two
        call fill_after( &
                self%target, self%pos(self%istart:self%iend-1), self%work_ket)

        self%weight = sandwich( &
                self%target, self%pos(self%iend-1:self%iend), self%work_ket)

        if (debug_validate_grow_move) &
            call assert_close(self%weight, self%naive%weight, rtol=1d-8)
    end

    function grow_outer_state_for_outer_proposal(move) result(outerbl)
        type(ZImpurityGrow), intent(in) :: move
        integer :: outerbl, fixedsst, chnewpos
        real(c_double) :: chtau
        type(TLocalOper), allocatable :: old_ops(:), new_ops(:)

        allocate(old_ops, source=get_operators(move%target))
        allocate(new_ops, source=get_operators(move))

        ! Get position and time of final operator to be inserted
        call get_highest_changed_tau(old_ops, new_ops, chtau, chnewpos)

        ! We want the sequence of superstates (switchboard path) to stay the
        ! same between the inserted operators, so we first fetch the sst just
        ! before the last inserted operator and then continue onwards
        fixedsst = sst_at_time(move%target, chtau)
        outerbl = final_sst(fixedsst, new_ops(chnewpos:), move%target%psis)
    end function

    function grow_get_operators(self) result(ops)
        type(ZImpurityGrow), intent(in) :: self
        type(TLocalOper), allocatable :: ops(:)

        allocate(ops(self%new_size))
        ops(:self%new_size) = self%pos(:self%new_size)%spec
    end function

    subroutine p_grow_get_newidx_addorder(move, out)
        type(ZImpurityGrow), intent(in)   :: move
        integer, allocatable, intent(out) :: out(:)

        call copy(move%inspos(:move%rank), out)
    end subroutine

    subroutine grow_accept(self)
        class(ZImpurityGrow), intent(inout) :: self
        integer :: inew, iold

        ! Now, we basically have the situation like this:
        !
        !                 1       istart                iend     new_size
        !                 |         |                     |         |
        !    after:       - ... - - @ @ @ @ @ ... @ @ @ @ X X X ... X
        !    before:      X ... X X X X X X X ... X X X X @ - - ... -
        !
        ! where "-" denotes vectors to be taken from the old configuration,
        ! "@" denotes items already recomputed and "X" items still to be
        ! recomputed.
        call fill_after( &
                self%target, self%pos(self%iend-1:self%new_size), self%work_ket)
        call fill_before(self%target, self%pos(:self%iend), self%work_bra)

        do inew = 1, self%istart-1
            iold = self%perm(inew)
            call swap(self%target%pos(iold)%after, self%pos(inew)%after)
        enddo
        do inew = self%iend+1, self%new_size
            iold = self%perm(inew)
            call swap(self%target%pos(iold)%before, self%pos(inew)%before)
        enddo

        ! Now we can simply do a swap of the two position arrays
        call swap_pos_array(self%pos, self%target%pos)
        self%target%weight = self%weight
        self%target%outer_sst = self%outer_sst
        self%target%size = self%new_size

        call fill_allowed_outer(self%target)

        if (debug_validate_grow_move) &
            call verify_impurity(self%target, 1d-8)
    end

    ! =========================================================================
    ! SHRINK MOVE
    ! =========================================================================

    subroutine p_init_shrink_impurity(self, t)
        type(ZImpurityShrink), intent(out) :: self
        type(ZImpurity), intent(inout), target :: t

        call init_update_base(self, t)
        call init_replace_impurity(self%naive, t)
    end subroutine

    subroutine p_propose_shrink_impurity(self, idx, outer_sst)
        type(ZImpurityShrink), intent(inout) :: self
        integer, intent(in) :: idx(:)
        integer, intent(in), optional :: outer_sst

        type(TLocalOper), allocatable :: ops_new(:)
        integer :: i, iold, old_size

        ! Prepare move
        old_size = self%target%size
        call shrink_resize(self, old_size - size(idx), size(idx))

        ! Copy indices to be removed and sort them for easier computations
        self%irem(:self%rank) = idx
        call sort(self%irem(:self%rank))

        ! Compute permutation, checking indices in the process
        call shrink_perm(old_size, self%irem(:self%rank), self%perm(:old_size))

        ! Copy over operator specifications to the new positions
        do i = 1, self%new_size
            iold = self%perm(i)
            self%pos(i)%spec = self%target%pos(iold)%spec
        enddo

        ! Initialize weights
        self%outer_sst = -2
        self%weight = ZERO

        ! Validate against global move if so desired
        if (debug_validate_shrink_move) then
            ops_new = self%pos(:self%new_size)%spec
            call propose_replace_impurity(self%naive, ops_new)
        endif
    end

    subroutine shrink_resize(self, new_size, rank)
        type(ZImpurityShrink), intent(inout) :: self
        integer, intent(in) :: new_size, rank

        self%rank = rank
        self%new_size = new_size
        call reserve(self%perm, new_size + rank)
        call reserve(self%irem, rank)
        call reserve_pos(self%pos, new_size)
    end

    subroutine shrink_choose_matching_outer_state(self, outer)
        type(ZImpurityShrink), intent(inout) :: self
        logical, intent(in) :: outer

        if (outer) then
            call shrink_outer_proposal(self)
        else
            call shrink_inner_proposal(self)
        endif
    end

    subroutine shrink_inner_proposal(self)
        type(ZImpurityShrink), intent(inout) :: self
        type(ZTOperator), pointer :: op
        integer :: iend_old, sst_front, sst_back, sst

        if (debug_validate_shrink_move) &
            call choose_outer_state(self%naive, self%target%outer_sst)

        ! An inner proposal is defined as one that leaves the outer sst
        ! invariant. As such, it touches only operators within the span of
        ! the inserted operators
        self%outer_sst = self%target%outer_sst

        ! Special case for zero size
        if (self%new_size == 0) then
            self%weight = partition_function(&
                        self%target%hloc, self%target%beta, self%outer_sst)
            self%istart = 1
            self%iend = 0
            return
        endif

        ! Figure out where the first removed operator lies. Here we have to
        ! account for the fact that if all elements to be removed are at the
        ! front (indicated by `all_front`), then the range [istart+1:iend-1]
        ! is the range [istart:iend-1] and thus we have to adjust the sst
        self%start_front = self%irem(1) == 1
        if (self%start_front) then
            self%istart = 1
            self%all_front = self%irem(self%rank) == self%rank
            if (self%all_front) then
                sst_front = self%outer_sst
            else
                op => get_psi_for_localoper(self%target%psis, self%pos(1)%spec)
                sst_front = connecting_sst(op, self%outer_sst)
            endif
        else
            self%istart = self%irem(1) - 1
            self%all_front = .false.
            sst_front = get_sst(self%target%pos(self%istart)%after)
        endif

        ! Figure out where the last removed operator lies. A similar reasoning
        ! as with `all_front` is stored in `all_back`.
        self%end_back = self%irem(self%rank) == self%target%size
        if (self%end_back) then
            self%iend = self%new_size
            iend_old = -1
            self%all_back = self%irem(1) == self%new_size + 1
            if (self%all_back) then
                sst_back = self%outer_sst
            else
                op => get_psi_for_localoper( &
                            self%target%psis, self%pos(self%new_size)%spec)
                sst_back = connecting_sst_backwards(op, self%outer_sst)
            endif
        else
            iend_old = self%irem(self%rank) + 1
            self%iend = iend_old - self%rank
            self%all_back = .false.
            sst_back = get_sst(self%target%pos(iend_old)%before)
        endif

        ! First, check quantum numbers
        sst = final_sst_pos( &
                    sst_front, self%pos(self%istart+1:self%iend-1), &
                    self%target%psis)
        if (sst_back == -1 .or. sst /= sst_back) then
            self%weight = ZERO
            self%outer_sst = -1
        endif

        if (self%outer_sst < 0 .and. debug_validate_shrink_move) &
            call assert_close(self%weight, self%naive%weight)
    end

    subroutine shrink_outer_proposal(self)
        type(ZImpurityShrink), intent(inout) :: self
        real(c_double) :: bunch_tau
        integer :: irem_highest, isst, istart, istart_new, sst_start, sst_match
        integer :: sst_naive, irem_pos

        if (debug_validate_shrink_move) then
            sst_naive = shrink_outer_state_for_outer_proposal(self)
            call choose_outer_state(self%naive, sst_naive)
            !call dump(self%target)
            !call print_array(self%irem(:self%rank), name='IREM')
        endif

        ! An outer proposal is defined as one which leaves the sst at the time
        ! just before the latest removed operator invariant, e.g.:
        !
        !                 ---|---|------X----|----X-----XX-----|-------> tau
        !     old index      1   2      3    4    5     67     8
        !     new index      1   2           3                 4
        !
        ! where indices 3,5,6,7 are to be removed (6,7 are at the same time).
        ! Then the sst to the after operator at old index 5 is the sst to be
        ! followed.
        irem_highest = self%irem(self%rank)
        bunch_tau = self%target%pos(irem_highest)%spec%tau
        irem_pos = self%rank - 1
        do isst = irem_highest - 1, 1, -1
            if (self%target%pos(isst)%spec%tau /= bunch_tau) &
                exit
            if (isst == self%irem(irem_pos)) &
                irem_pos = irem_pos - 1
        enddo
        if (isst == 0) &
            error stop 'All operators are removed at the same time'

        sst_start = get_sst(self%target%pos(isst)%after)

        ! Now, find the last old index prserved.
        istart = isst
        do irem_pos = irem_pos, 1, -1
            if (istart /= self%irem(irem_pos)) &
                exit
            istart = istart - 1
        enddo

        ! There is a special case, where all operators to be removed are at
        ! at the beginning, e.g:
        !
        !                 ---X---XX-----|----|----|------------|-------> tau
        !     old index      1   23     4    5    6            7
        !     new index                 1    2    3            4
        !
        ! Note that even in this case the old outer_sst is not preserved, so
        ! it does not transpose to an inner proposal.
        istart_new = istart - irem_pos

        ! In order to figure out the outer sst, we move the sst through
        ! the sequence of operators until the end
        self%outer_sst = final_sst_pos( &
                sst_start, self%pos(istart_new+1:self%new_size), &
                self%target%psis)

        if (debug_validate_shrink_move) then
            call assert_equal(self%outer_sst, sst_naive)
        endif

        ! Now, check quantum numbers: this has to be done from the beginning
        ! to position isst, then we have to match the sst
        sst_match = final_sst_pos( &
                    self%outer_sst, self%pos(:istart_new), self%target%psis)

        if (sst_match /= sst_start) then
            self%weight = ZERO
            self%outer_sst = -1
        endif

        ! Do the full evolution :(
        self%istart = 1
        self%iend = self%new_size
        self%start_front = .true.
        self%end_back = .true.
        self%all_front = .false.
        self%all_back = .false.

        if (self%outer_sst < 0 .and. debug_validate_grow_move) &
            call assert_close(self%weight, self%naive%weight)
    end

    subroutine shrink_compute_weight(self)
        type(ZImpurityShrink), intent(inout) :: self
        integer :: iend_old

        ! Special case for zero size
        if (self%new_size == 0) then
            self%weight = partition_function(&
                        self%target%hloc, self%target%beta, self%outer_sst)
            goto 99
        endif

        ! In "edge" cases we have to initialize new starting vectors for the
        ! forward and/or backward evaluation
        if (self%start_front) then
            call first_after(self%target, self%pos(self%istart), self%outer_sst)
        else
            call copy(self%target%pos(self%istart)%after, &
                      self%pos(self%istart)%after)
        endif
        if (self%end_back) then
            call last_before(self%target, self%pos(self%iend), self%outer_sst)
        else
            iend_old = self%iend + self%rank
            call copy(self%target%pos(iend_old)%before, &
                      self%pos(self%iend)%before)
        endif

        if (self%all_front) then
            self%weight = trace_boltzmann( &
                self%target%hloc, self%pos(1)%spec%tau, self%pos(1)%before)
        elseif (self%all_back) then
            self%weight = trace_boltzmann( &
                self%target%hloc, &
                self%target%beta - self%pos(self%new_size)%spec%tau, &
                self%pos(self%new_size)%after)
        else
            ! Compute forward path between the two
            call fill_after( &
                    self%target, self%pos(self%istart:self%iend-1), &
                    self%work_ket)
            self%weight = sandwich( &
                    self%target, self%pos(self%iend-1:self%iend), &
                    self%work_ket)
        endif

    99  if (debug_validate_shrink_move) &
            call assert_close(self%weight, self%naive%weight, rtol=1d-8)
    end

    function shrink_outer_state_for_outer_proposal(move) result(outerbl)
        type(ZImpurityShrink), intent(in) :: move
        integer :: outerbl, fixedsst, chnewpos
        real(c_double) :: chtau
        type(TLocalOper), allocatable :: old_ops(:), new_ops(:)

        allocate(old_ops, source=get_operators(move%target))
        allocate(new_ops, source=get_operators(move))

        ! Get time of final operator to be removed and (unaltered) operator
        ! just before that.
        call get_highest_changed_tau(old_ops, new_ops, chtau, chnewpos)

        ! Add one to skip ahead after the removed operators
        chnewpos = chnewpos + 1

        ! We want the sequence of superstates (switchboard path) to stay the
        ! same between the removed operators, so we first fetch the sst just
        ! before the last removed operator and then continue onwards with
        ! the remaining operators.
        fixedsst = sst_at_time(move%target, chtau)
        outerbl = final_sst(fixedsst, new_ops(chnewpos:), move%target%psis)
    end function

    function shrink_get_operators(self) result(ops)
        type(ZImpurityShrink), intent(in) :: self
        type(TLocalOper), allocatable :: ops(:)

        allocate(ops(self%new_size))
        ops(:self%new_size) = self%pos(:self%new_size)%spec
    end function

    subroutine shrink_accept(self)
        class(ZImpurityShrink), intent(inout) :: self
        integer :: inew, iold, istart_after

        ! Now, we basically have the situation like this:
        !
        !                 1       istart                iend     new_size
        !                 |         |                     |         |
        !    after:       - ... - - @ @ @ @ @ ... @ @ @ @ X X X ... X
        !    before:      X ... X X X X X X X ... X X X X @ - - ... -
        !
        ! where "-" denotes vectors to be taken from the old configuration,
        ! "@" denotes items already recomputed and "X" items still to be
        ! recomputed.
        istart_after = max(self%iend - 1, self%istart)
        call fill_after( &
                self%target, self%pos(istart_after:self%new_size), &
                self%work_ket)
        call fill_before(self%target, self%pos(:self%iend), self%work_bra)

        ! Every operator in new is also in old
        do inew = 1, self%istart-1
            iold = self%perm(inew)
            call swap(self%target%pos(iold)%after, self%pos(inew)%after)
        enddo
        do inew = self%iend+1, self%new_size
            iold = self%perm(inew)
            call swap(self%target%pos(iold)%before, self%pos(inew)%before)
        enddo

        ! Now we can simply do a swap of the two position arrays
        call swap_pos_array(self%pos, self%target%pos)
        self%target%weight = self%weight
        self%target%outer_sst = self%outer_sst
        self%target%size = self%new_size

        call fill_allowed_outer(self%target)

        if (debug_validate_grow_move) &
            call verify_impurity(self%target, 1d-8)
    end subroutine

    ! =========================================================================
    ! SHIFT MOVE
    ! =========================================================================

    subroutine p_init_shift_impurity(self, t)
        type(ZImpurityShift), intent(out) :: self
        type(ZImpurity), intent(inout), target :: t

        call init_update_base(self, t)
        call init_replace_impurity(self%naive, t)
    end subroutine

    subroutine p_propose_shift_impurity(self, delta_tau)
        type(ZImpurityShift), intent(inout) :: self
        real(c_double), intent(in) :: delta_tau

        integer :: i, outer_sst, old_size
        type(TLocalOper) :: ops_upd(self%target%size)

        if (.not. (delta_tau >= 0 .and. delta_tau < self%target%beta)) &
            error stop 'Invalid shift'

        old_size = self%target%size
        call reserve(self%perm, old_size)

        if (old_size == 0) then
            self%new_first = 1
            outer_sst = self%target%outer_sst
        else
            self%new_first = position_after_tau(self%target, delta_tau)
            call cyclic_perm(old_size, self%new_first - 1, &
                             self%perm(:old_size))

            do i = 1, old_size
                ops_upd(i) = self%target%pos(self%perm(i))%spec
                ops_upd(i)%tau = ops_upd(i)%tau - delta_tau
                if (ops_upd(i)%tau < 0) &
                    ops_upd(i)%tau = ops_upd(i)%tau + self%target%beta
            enddo
            outer_sst = get_sst(self%target%pos(self%new_first)%before)
        endif

        call propose_replace_impurity(self%naive, ops_upd)

        call choose_outer_state(self%naive, outer_sst)
        self%outer_sst = self%naive%outer_sst
    end

    integer function p_get_num_wrapped_ops(self) result(n)
        type(ZImpurityShift), intent(in) :: self

        n = self%new_first
    end

    ! =========================================================================
    ! UPDATE MOVE
    ! =========================================================================

    subroutine p_init_update_impurity(self, t)
        type(ZImpurityUpdate), intent(out) :: self
        type(ZImpurity), intent(inout), target :: t

        call init_update_base(self, t)
        call init_replace_impurity(self%naive, t)
    end subroutine

    subroutine p_propose_update_impurity(self, idx, ops, outer_sst)
        type(ZImpurityUpdate), intent(inout) :: self
        integer, intent(in) :: idx(:)
        type(TLocalOper), intent(in) :: ops(:)
        integer, intent(in), optional :: outer_sst

        type(TLocalOper) :: ops_upd(self%target%size)
        type(TLocalOper) :: ops_upd_perm(self%target%size)
        real(c_double) :: taus(self%target%size)
        integer :: i, old_size, invperm(self%target%size)
        logical, parameter :: verify_inspos = .false.

        call check_opers(self%target, ops)
        if (any(idx < 1) .or. any(idx > self%target%size)) &
            error stop 'Invalid index'
        if (size(idx) /= size(ops)) &
            error stop 'Indices and ops must be of same size'

        old_size = self%target%size
        self%rank = size(idx)

        call reserve(self%perm, old_size)
        call reserve(self%remidx, self%rank)
        call reserve(self%inspos, self%rank)

        self%remidx(:self%rank) = idx

        ops_upd(:) = self%target%pos(:old_size)%spec
        do i = 1, size(idx)
            ops_upd(idx(i)) = ops(i)
        enddo

        taus(:) = ops_upd(:)%tau
        call sort_perm(taus, self%perm(:old_size))
        ops_upd_perm(:) = ops_upd(self%perm(:old_size))

        call inv_perm(self%perm(:old_size), invperm)
        self%inspos(:self%rank) = invperm(idx)

        if (verify_inspos) then
            do i = 1, self%rank
                if (.not. (ops_upd_perm(self%inspos(i)) == ops(i))) &
                    error stop 'Invalid inspos'
            enddo
        endif

        call propose_replace_impurity(self%naive, ops_upd_perm, outer_sst)
    end

    subroutine p_update_get_newidx_addorder(move, out)
        type(ZImpurityUpdate), intent(in) :: move
        integer, allocatable, intent(out) :: out(:)

        call copy(move%inspos(:move%rank), out)
    end subroutine

    subroutine update_choose_matching_outer_state(self, outer)
        type(ZImpurityUpdate), intent(inout) :: self
        logical, intent(in) :: outer

        if (outer) &
            error stop 'XXX Not implemented'

        call choose_outer_state(self, self%target%outer_sst)
    end

    ! -------------------------------------------------------------------------
    ! OUTER STATE PROPOSALS
    ! XXX these functions are somewhat misplaced here :/

    !> Get the highest tau and indices into the operator lists from
    !> where on downwards the sequence and thus the time-evolved state
    !> (and superstate) are different for the operator arrray oldops
    !> than for newops.
    !>
    !> @param oldops First operator array
    !> @param newops Second operator array
    !> @param tau Largest tau at which the sequences start to differ
    !> @param oldpos Index of the differing operator in oldops with the
    !>               highest index or zero if oldops only differs by
    !>               missing at most the operators in newops with smallest
    !>               tau
    !> @param newpos Index into newpos analogous to oldpos for oldops
    subroutine get_highest_changed_tau(oldops, newops, tau, newpos)
        type(TLocalOper), intent(in) :: oldops(:), newops(:)
        real(c_double), intent(out)  :: tau
        integer, intent(out)         :: newpos
        integer                      :: oldpos, idx

        ! Determine the largest tau from which on toward tau=0 the
        ! sequences of operators differ as well as the highest indices
        ! of different elements in the sequences at the same index
        ! position counting from the end
        idx = index_of_first_nonequal(oldops(size(oldops):1:-1), &
                                      newops(size(newops):1:-1))
        oldpos = size(oldops) + 1 - idx
        newpos = size(newops) + 1 - idx

        ! If the end of one of the sequences is reached, the
        ! sequences differ from the tau of the current operator in
        ! the other sequence on
        if (oldpos == 0) then
            if (newpos == 0) &
                error stop 'Operators are not different'
            tau = newops(newpos)%tau
        else if (newpos == 0) then
            tau = oldops(oldpos)%tau
        else
            tau = max(oldops(oldpos)%tau, newops(newpos)%tau)
        end if
    end subroutine get_highest_changed_tau

    pure function index_of_first_nonequal(op1, op2) result(idx)
        type(TLocalOper), intent(in) :: op1(:), op2(:)
        integer :: idx

        do idx = 1, min(size(op1), size(op2))
            if (.not. (op1(idx) == op2(idx))) &
                exit
        enddo
    end function

    function final_sst(initial_sst, ops, psi)
        integer, intent(in) :: initial_sst
        type(TLocalOper), intent(in) :: ops(:)
        type(ZTPsis), intent(in) :: psi
        type(ZTOperator), pointer :: op
        integer :: i, final_sst

        final_sst = initial_sst
        do i = 1, size(ops)
           op => get_psi_for_localoper(psi, ops(i))
           final_sst = connecting_sst(op, final_sst)
        enddo
    end function

end module
