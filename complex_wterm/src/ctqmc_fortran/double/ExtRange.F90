! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.


module MExtRangeD
    use iso_c_binding, only: c_long, c_double, c_double_complex
    use MComplexNumbers, only: sign, scale
    use Testing, only: isclose, assert_close, terminate
    implicit none
    private

    !> Complex type with extended range (useful for determinants)
    type, public :: DExtRange
        private
        real(c_double) :: val = 1
        integer(c_long) :: exp = 0
    end type

    !> Convert real/complex into variables with extended range
    interface extrange
        module procedure p_extend_range
    end interface
    public extrange

    !> Convert variable with extended range into real/complex
    interface limrange
        module procedure p_limrange
    end interface
    public limrange

    interface DExtRange
        module procedure p_copy, p_extend_range, p_construct



    end interface

    interface assignment ( = )
        module procedure p_assign_scalar



    end interface
    public assignment ( = )

    interface operator ( + )
        module procedure p_pos, p_add
    end interface
    public operator ( + )

    interface operator ( - )
        module procedure p_neg, p_sub
    end interface
    public operator ( - )

    !> Multiply extended-range numbers (avoids overflows)
    interface operator ( * )
        module procedure p_mul, p_mul_scalar



    end interface
    public operator ( * )

    !> Divide extended-range numbers (avoids overflows)
    interface operator ( / )
        module procedure p_div, p_div_scalar, p_div_lscalar



    end interface
    public operator ( / )

    !> Print number
    interface dump
        module procedure p_dump
    end interface
    public dump

    interface isclose
        module procedure p_isclose
    end interface
    public isclose

    interface assert_close
        module procedure p_assert_close
    end interface
    public assert_close

    interface exponent
        module procedure p_exponent
    end interface
    public exponent

    interface fraction
        module procedure p_fraction
    end interface
    public fraction

    interface split
       module procedure p_split
    end interface
    public split

    interface scale
        module procedure p_scale
    end interface
    public scale

    interface sign
        module procedure p_sign
    end interface
    public sign

    interface renormalize
        module procedure p_renormalize
    end interface

    interface rescale
        module procedure p_rescale
    end interface
    public rescale

    interface conjg
        module procedure p_conjg
    end interface
    public conjg


    interface extended_exp
        module procedure p_extended_exp
    end interface
    public extended_exp

    interface exp
        module procedure p_exp
    end interface
    public exp


contains
    pure elemental function p_pos(x) result(r)
        type(DExtRange), intent(in) :: x
        type(DExtRange) :: r

        r = x
    end

    pure elemental function p_neg(x) result(r)
        type(DExtRange), intent(in) :: x
        type(DExtRange) :: r

        r%val = -x%val
        r%exp = x%exp
    end

    pure elemental function p_add(x, y) result(r)
        type(DExtRange), intent(in) :: x, y
        type(DExtRange) :: r
        real(c_double) :: xval, yval
        integer(c_long) :: expon

        call rescale(x, y, xval, yval, expon)
        r%val = xval + yval
        r%exp = expon
        r = renormalize(r)
    end

    pure elemental function p_sub(x, y) result(r)
        type(DExtRange), intent(in) :: x, y
        type(DExtRange) :: r
        real(c_double) :: xval, yval
        integer(c_long) :: expon

        call rescale(x, y, xval, yval, expon)
        r%val = xval - yval
        r%exp = expon
        r = renormalize(r)
    end

    pure subroutine p_rescale(x, y, xval, yval, expon)
        type(DExtRange), intent(in) :: x, y
        real(c_double), intent(out) :: xval, yval
        integer(c_long), intent(out) :: expon
        integer(c_long) :: expdiff

        expdiff = x%exp - y%exp
        if (expdiff >= 0) then
            xval = x%val
            yval = scale(y%val, -expdiff)
            expon = x%exp
        else
            xval = scale(x%val, expdiff)
            yval = y%val
            expon = y%exp
        endif
    end

    pure elemental function p_mul(x, y) result(r)
        type(DExtRange), intent(in) :: x, y
        type(DExtRange) :: r

        r%val = x%val * y%val
        r%exp = x%exp + y%exp
        r = renormalize(r)
    end

    pure elemental function p_mul_scalar(x, y) result(r)
        type(DExtRange), intent(in) :: x
        real(c_double), intent(in) :: y
        type(DExtRange) :: r

        r%val = x%val * y
        r%exp = x%exp
        r = renormalize(r)
    end

    pure elemental function p_div(x, y) result(r)
        type(DExtRange), intent(in) :: x, y
        type(DExtRange) :: r

        r%val = x%val / y%val
        r%exp = x%exp - y%exp
        r = renormalize(r)
    end

    pure elemental function p_div_scalar(x, y) result(r)
        type(DExtRange), intent(in) :: x
        real(c_double), intent(in) :: y
        type(DExtRange) :: r

        r%val = x%val / y
        r%exp = x%exp
        r = renormalize(r)
    end

    pure elemental function p_div_lscalar(x, y) result(r)
        real(c_double), intent(in) :: x
        type(DExtRange), intent(in) :: y
        type(DExtRange) :: r

        r%val = x / y%val
        r%exp = -y%exp
        r = renormalize(r)
    end


    pure elemental function p_extend_range(x) result(r)
        real(c_double), intent(in) :: x
        type(DExtRange) :: r

        r%exp = 0
        r%val = x
        r = renormalize(r)
    end

    pure elemental function p_copy(x) result(r)
        type(DExtRange), intent(in) :: x
        type(DExtRange) :: r

        r = x
    end

    pure elemental function p_construct(val, expon) result(r)
        real(c_double), intent(in) :: val
        integer(c_long), intent(in) :: expon
        type(DExtRange) :: r

        r%val = val
        r%exp = expon
        r = renormalize(r)
    end

    pure subroutine p_assign_scalar(self, x)
        type(DExtRange), intent(out) :: self
        real(c_double), intent(in) :: x

        self = extrange(x)
    end


    pure elemental function p_limrange(x) result(r)
        type(DExtRange), intent(in) :: x
        real(c_double) :: r

        r = scale(x%val, x%exp)
    end

    pure elemental function p_exponent(x) result(r)
        type(DExtRange), intent(in) :: x
        integer(c_long) :: r

        r = x%exp
    end

    pure elemental function p_fraction(x) result(r)
        type(DExtRange), intent(in) :: x
        real(c_double) :: r

        r = x%val
    end

    pure elemental function p_sign(x, y) result(r)
        real(c_double), intent(in) :: x
        type(DExtRange), intent(in) :: y
        real(c_double) :: r

        r = sign(x, y%val)
    end

    pure elemental function p_conjg(x) result(r)
        type(DExtRange), intent(in) :: x
        type(DExtRange) :: r

        r%exp = x%exp
        r%val = x%val
    end

    pure elemental function p_scale(x, n) result(r)
        type(DExtRange), intent(in) :: x
        integer, intent(in) :: n
        type(DExtRange) :: r

        r%val = x%val
        r%exp = x%exp + n
    end

    pure elemental function p_renormalize(x) result(r)
        type(DExtRange), intent(in) :: x
        type(DExtRange) :: r

        call split(x%val, r%val, r%exp)
        r%exp = r%exp + x%exp
    end

    pure subroutine p_split(val, fract, expon)
        real(c_double), intent(in) :: val
        real(c_double), intent(out) :: fract
        integer(c_long), intent(out) :: expon
        intrinsic :: fraction, exponent

        fract = fraction(val)
        expon = exponent(val)
    end

    pure logical function p_isclose(a, b, rtol) result(result)
        type(DExtRange), intent(in) :: a, b
        real(c_double), intent(in), optional :: rtol
        real(c_double) :: aval, bval
        integer(c_long) :: expon

        call rescale(a, b, aval, bval, expon)
        result = isclose(aval, bval, rtol=rtol)
    end

    subroutine p_assert_close(a, b, rtol, file, line)
        type(DExtRange), intent(in) :: a, b
        real(c_double), intent(in), optional :: rtol
        character(len=*), intent(in), optional :: file
        integer, intent(in), optional :: line

        if (isclose(a, b, rtol=rtol)) &
            return

        write (*,*) 'a ='
        call dump(a)
        write (*,*) 'b ='
        call dump(b)
        call terminate('significant difference between scalars', file, line)
    end subroutine

    subroutine p_dump(x, unit)
        type(DExtRange), intent(in) :: x
        integer, intent(in), optional :: unit
        integer(c_long) :: exp10
        real(c_double) :: ffact

        call tobase10(x%exp, exp10, ffact)

        write (get_unit(unit), 99) x%val * ffact, exp10

    99  format (F19.16, 'E', SP, I0)
    end subroutine

    subroutine tobase10(e2, e10, ffact)
        integer(c_long), intent(in) :: e2
        integer(c_long), intent(out) :: e10
        real(c_double), intent(out) :: ffact

        real(c_double) :: e10r
        real(c_double), parameter :: log10_radix = log10(1.0d0 * radix(1.0d0))

        e10r = log10_radix * e2
        e10 = nint(e10r, kind=c_long)
        ffact = 10.0d0**(e10r - e10)
    end

    pure integer function get_unit(unit)
        integer, intent(in), optional :: unit

        if (present(unit)) then
            get_unit = unit
        else
            get_unit = 6
        endif
    end

    pure elemental function p_extended_exp(x) result(r)
        real(c_double), value :: x
        type(DExtRange) :: r
        real(c_double) :: n, y

        real(c_double), parameter :: LOG2 = log(2.0d0)
        real(c_double), parameter :: INV_LOG2 = 1 / log(2.0d0)
        real(c_double), parameter :: HUGEARG = log(HUGE(1.0d0))

        ! Fast path for the most common case
        if (abs(x) < HUGEARG) then
            r = extrange(exp(x))
            return
        endif

        ! XXX: calculation should be done with extended precision, because the
        ! reduction mod(log(2)), even if done in exact arithmetic, results in
        ! an error which is then amplified through exp(...):
        !
        !     dy/y = exp(x + eps x) / exp(x) - 1 = eps * x + O(dx^2)
        !
        ! i.e., one expects larger errors in this case. Since this results is
        ! quite a significant performance bottleneck, we don't do this yet:
        n = floor(INV_LOG2 * x)
        y = x - n * LOG2
        r%val = exp(y)
        r%exp = int(n, c_long)
    end

    pure elemental function p_exp(x) result(r)
        type(DExtRange), intent(in) :: x
        type(DExtRange) :: r

        r = extended_exp(limrange(x))
    end

end module
