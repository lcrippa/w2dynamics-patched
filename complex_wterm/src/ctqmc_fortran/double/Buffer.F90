! === DO NOT EDIT THIS FILE! ===
! It is automatically generated from the corresponding .tmpl.F90 file
! during the build process.


module MBufferD
    use iso_c_binding, only: c_double, c_double_complex
    implicit none
    private

    interface reserve
        module procedure p_reserve_1, p_reserve_2



    end interface
    public reserve

    interface copy
        module procedure p_copy_1
    end interface
    public copy




    real(c_double), parameter :: ONE = 1
    real(c_double), parameter :: default_value = huge(ONE)


contains

    subroutine p_reserve_1(buf, rowcap, preserve)
        real(c_double), allocatable, intent(inout) :: buf(:)
        integer, intent(in) :: rowcap
        logical, intent(in), optional :: preserve
        real(c_double), allocatable :: tmp(:)

        if (allocated(buf)) then
            if (rowcap <= size(buf, 1)) &
                return
            if (value_or_false(preserve)) then
                call move_alloc(buf, tmp)
            else
                deallocate(buf)
            endif
        endif
        allocate(buf(rowcap), source=default_value)
        if (allocated(tmp)) then
            buf(:size(tmp, 1)) = tmp(:)
        endif
    end subroutine

    subroutine p_reserve_2(buf, rowcap, colcap, preserve)
        real(c_double), allocatable, intent(inout) :: buf(:,:)
        integer, intent(in) :: rowcap, colcap
        logical, intent(in), optional :: preserve
        real(c_double), allocatable :: tmp(:,:)

        if (allocated(buf)) then
            if (rowcap <= size(buf, 1) .and. colcap <= size(buf, 2)) &
                return
            if (value_or_false(preserve)) then
                call move_alloc(buf, tmp)
            else
                deallocate(buf)
            endif
        endif
        allocate(buf(rowcap, colcap), source=default_value)
        if (allocated(tmp)) then
            buf(:size(tmp, 1), :size(tmp, 2)) = tmp(:, :)
        endif
    end subroutine


    subroutine p_copy_1(val, buf)
        real(c_double), intent(in) :: val(:)
        real(c_double), allocatable, intent(inout) :: buf(:)

        if (allocated(buf)) then
            if (size(buf) /= size(val)) &
                deallocate(buf)
        endif
        if (allocated(buf)) then
            buf(:) = val(:)
        else
            allocate(buf, source=val)
        endif
    end subroutine

    pure logical function value_or_false(preserve)
        logical, intent(in), optional :: preserve

        if (present(preserve)) then
            value_or_false = preserve
        else
            value_or_false = .false.
        endif
    end function

end module
