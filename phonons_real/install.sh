#!/bin/bash
# installs Python 2.7.3 and all python dependencies for the CTQMC

set -e

ENSURE_GCC=env CC=gcc CXX=g++ FC=gfortran F77=g77
ENSURE_MPICC=env CC=mpicc CXX=mpicxx FC=mpif90 F77=mpif77
INSTALL_DIR=$HOME/opt
SOURCE_DIR=$HOME/opt/src
SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
PYLIB_DIR=$HOME/opt/lib/python
if [ -f $HOME/.profile ]; then
	PROFILE_FILE=$HOME/.profile
elif [ -f $HOME/.bash_profile ]; then
	PROFILE_FILE=$HOME/.bash_profile
else
	echo "No bash startup file found!"
	echo "Please set PROFILE_FILE in the install script by hand!"
fi
echo $PROFILE_FILE
CTQMC_PROFILE=$HOME/.ctqmc/profile
CTQMC_COMPLETIONS=$HOME/.ctqmc/completions
REQUIRE_PYTHON=2,7
PYTHON=python

DO_NOT_ASK=
ask() {
    local answer
    echo >&2
    echo "$1" >&2
    if [ ! -z "$DO_NOT_ASK" ]; then
        return 0
    fi
    while true; do
        read -p "[Y]es, yes to [a]ll, [n]o, [q]uit:" answer >&2
        case $answer in
            [yY] ) return 0;;
            [aA] ) DO_NOT_ASK=1; return 0;;
            [nN] ) return 1;;
            [qQ] ) echo "Aborted installer." >&2; exit 1;;
        esac
    done
}

THINGS_DONE=()
just_did() {
    THINGS_DONE+=("$1")
}

update() {
    echo "Checking whether $(basename $2) is up-to-date..."
    if ! diff -q $1 $2 2>/dev/null; then
	if ask "File $2 is outdated. Update?"; then
	    mkdir -p $(dirname $2)
	    cp $1 $2
	    just_did "Updated $2 with $1"
	fi
    fi
}

get_tarball() {
    mkdir -p $SOURCE_DIR
    $DOWNLOADER $1 | tar -xz -C $SOURCE_DIR
}

install() {
    cd $SOURCE_DIR/$1
    echo "CONFIGURING..."
    ./configure --prefix=$INSTALL_DIR $2
    echo "BUILDING..."
    make
    echo "INSTALLING..."
    make install
    just_did "compiled and installed $1 to $INSTALL_DIR"
}

install_pip() {
    echo "Installing distribute..."
    $DOWNLOADER https://bootstrap.pypa.io/ez_setup.py \
        | $PYTHON - --user || exit 1
    just_did "set up python distribution (ez_setup.py)"

    echo "Installing pip..."
    get_tarball http://pypi.python.org/packages/source/p/pip/pip-1.0.tar.gz
    cd $SOURCE_DIR/pip-1.0
    $PYTHON setup.py install --user
    just_did "installed python package manager (pip)"
}

ensure_pip() {
    if [ -z $(which pip) ]; then
        if ask "Python package mangager (pip) not found. Install?"; then
            install_pip
        fi
    fi
}

ensure_package() {
    echo "Checking for package $1..."
    if ! $PYTHON -c "import $1"; then
        if ask "Python package $1 was not found. Install?"; then
            ensure_pip
            pip install --user $1
            just_did "installed python package $1"
        fi
    fi
}

tmp_profile=$(mktemp)
cat <<EOF >>$tmp_profile
#!/bin/bash
# This file is generated by the CT-QMC installer script and is sourced in a
# .bash_profile. DO NOT EDIT THIS FILE - it will be overridden each time you
# invoke the install script

# Fixes signalling behaviour of TORQUE's qsig. This is necessary because qsig by
# default forwards signals to all processes of the job's process group, which
# also includes the execution environment (log-in shell). Therefore, the log-in
# shell will exit and will take the job with it using SIGTERM even if the jobs
# handle it correctly.
if [ ! -z "\$PBS_ENVIRONMENT" ]; then
    echo "Running in PBS env, fix TORQUE's signal trapping..."
    trap "" USR1 USR2
fi

# Python base directory for user packages. This is to correctly resolve the imports
export PYTHONUSERBASE=$INSTALL_DIR
export PATH=$INSTALL_DIR/bin:\$PATH
export MANPATH=$INSTALL_DIR/share/man:\$MANPATH
export INCLUDE=$INSTALL_DIR/include:\$INCLUDE

export LIBRARY_PATH=$INSTALL_DIR/lib:\$LIBRARY_PATH
export LD_RUN_PATH=$INSTALL_DIR/lib:\$LD_RUN_PATH

export DMFT_GIT_REVISION=$(cd $SCRIPT_DIR; git rev-parse HEAD || echo "unknown")

DMFT_PARAMETERS=(
$(awk '
   BEGIN { sec=""; subsec=""; }
   /^\[\[/ { subsec="1."; next; }
   /^\[/ { sec=substr($0, 2, length($0)-2) "."; subsec=""; next; }
   /^[^#=]*=/ { sub(/=.*/,""); print "  " sec subsec $1; }
' $SCRIPT_DIR/auxiliaries/configspec)
)

# TODO: generate that somehow from DMFT.py
HF_PARAMETERS=(


               accept-glob accept-ins accept-rem accept-worm-ins 
               accept-worm-rem accept-worm-rep at2neq chi-ph chi-pp config dc 
               dc-latt densitymatrix double-occ env error expresdensitymatrix 
               fiw fmom ftau g0iw g0iw-full g2iw g4iw g4iw-conn-ph g4iw-pp 
               g4leg g4tau giw giw-meas giw-worm gleg gloc glocold gsigmaiw 
               gsigmaiw-worm gtau gtau-worm hist hist-seg h-mean imp-density 
               imp-electrons iter latt-electrons lda-dens lda-mu leadsiw-full 
               lhist list moment mu muimp neq2at nneq ntau-n0 occ rhist rho1 
               rho2 run-date sigma-hartree sign single-occ siw siw-full smom 
               smom-full sztau_sz0 sztau_sz0_diag time time-g4iw-add 
               time-g4iw-ft time-giw time-qmc time-worm-partition version-code 
               version-git version-outfile)

HF_SHORTOPTS=(d h n t g p F)
HF_LONGOPTS=(debug help no-warn tabular version format no-derived gnuplot)

source $CTQMC_COMPLETIONS
EOF

chmod a+x $tmp_profile
update $tmp_profile $CTQMC_PROFILE
update $SCRIPT_DIR/completions.sh $CTQMC_COMPLETIONS
rm $tmp_profile

echo "Checking for CTQMC link in your ~/bash_profile..."
if ! grep "# BEGIN CTQMC ADDED" $PROFILE_FILE >/dev/null; then
    if ask "Add link to CTQMC profile file to your bash profile?"; then
        cat <<EOF >>$PROFILE_FILE
# BEGIN CTQMC ADDED
# Sourcing the CT-QMC configuration in:
source $CTQMC_PROFILE
# END CTQMC ADDED
EOF
        just_did "Included link to $CTQMC_PROFILE in $PROFILE_FILE"
    fi

    # Patch that in for the rest of the script
    source $CTQMC_PROFILE || echo "warning: unable to load $CTQMC_PROFILE"
fi

update DMFT.man  $INSTALL_DIR/share/man/man1/DMFT.py.1
update hgrep.man $INSTALL_DIR/share/man/man1/hgrep.1

#for manfile in *.man; do
#    manfile=$(basename $manfile)
#    update $manfile $INSTALL_DIR/share/man/man1/${manfile%%.man}.py.1
#done

# Check for downloader
echo "Selecting downloader..."
if [ -f /usr/bin/wget ]; then
    DOWNLOADER="wget --no-check-certificate -O -"
else
    DOWNLOADER="curl --no-check-certificate"
fi

# Get python of at least version $REQUIRE_PYTHON
echo "Checking for Python..."
if ! $PYTHON -c "import sys; sys.exit(not sys.version_info >= ($REQUIRE_PYTHON))"
then
    if ask "Python >= $REQUIRE_PYTHON was not found. Install?"; then
        get_tarball https://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz
        install Python-2.7.8
        # This does not seem to update
        PYTHON=$INSTALL_DIR/bin/python
        just_did "compiled and installed python 2.7.8"

        # We need a 'new' pip, since the old one does not support user-based install
        install_pip
    fi
fi

# installing packages
ensure_package numpy
ensure_package scipy
ensure_package configobj
ensure_package mpi4py

# Check if MPI4PY was compiled
echo "Checking for proper functioning of MPI..."
if ! python -c "from mpi4py import MPI"; then
    hostfile=$(mktemp)
    echo $(hostname) >$hostfile
    testprog=$(mktemp)
    echo "from mpi4py import MPI" >$testprog
    if ! mpirun -np 1 -hostfile $hostfile python $testprog; then
	DO_NOT_ASK=
	if ask "mpi4py fails to work with the current MPI environment.

This is due to the fact that python is far too cool a programming language
to develop stable modules. You might as well shoot yourself in the knee.
WARNING: shooting yourself in the knee cannot be undone and may seriously
endanger your health. This installer disclaims any liability for any damage,
including, but limited to, bullet wounds and/or knee injuries.

If you have the possibility to select a different MPI environment (usually through
programs like mpi-selector), you can uninstall the mpi4py module by answering yes,
change the mpi environment and try to re-run the installer later.

Uninstall mpi4py and exit installer?"; then
	    pip uninstall mpi4py
	    exit 1
	fi
    fi
    rm $hostfile
fi

# Check for HDF5 package
echo "Checking for h5py support..."
if [[ ! `python -c "import h5py; print 'YES'" 2>/dev/null` == YES* ]]; then
    if ask "Python HDF5 interface (h5py) was not found. Install?"; then
        for dir in $(echo "/usr/include:/usr/local/include:$INCLUDE" | tr ":" "\n")
        do
	    echo "Checking $dir for hdf5.h"
            if [ -f $dir/hdf5.h ]; then
                echo "Found hdf5.h in $dir, checking version of HDF5..."
                mpicc -xc - <<EOF >/dev/null && HDF_FOUND=$dir/..
#include "$dir/hdf5.h"
#if H5_VERS_MAJOR < 1 || (H5_VERS_MAJOR == 1 && H5_VERS_MINOR < 8)
#error H5PY requires at least version HDF 1.8, insufficient version in $dir.
#endif
int main() {}
EOF
            fi
            [ ! -z "$HDF_FOUND" ] && break
        done

	if [ -z "$HDF_FOUND" ]; then
	    text="HDF5 libraries (>= 1.8) were not found. Install?"
	else
	    text="HDF5 header were found in $HDF_FOUND. Install locally anyway?
NOTE: This is required for VSC2. The nay-sayers might argue along the lines of:
      a cluster should make the libraries transparent for the users. But since
      this poses some effort, one might as well abort all common sense and make
      /usr/lib64 unavailable on the computing nodes. Hell, it's not like that
      cost me one full day of work.
ALSO NOTE: this installer will cease to go on further rants, switch off all
      sarcasm and will be the boring technocratic slave catering to your
      glorious scientific carrier from now on. Enjoy. Or not. We do not feel.
So: install locally?"
	fi

        if ask "$text"; then
            get_tarball http://www.hdfgroup.org/ftp/HDF5/releases/hdf5-1.8.13/src/hdf5-1.8.13.tar.gz
            install hdf5-1.8.13 --enable-fortran
            HDF_FOUND=$INSTALL_DIR
            just_did "compiled and installed HDF5 libraries 1.8.13"
        fi

        # Now do the actual installation
        ensure_pip
	$ENSURE_GCC pip install Cython --user
	pip install --no-install h5py

	cd build/h5py
	$ENSURE_MPICC python setup.py configure --hdf5="$HDF_FOUND"
	patch -p0 <<EOF
--- h5py/__init__.py
+++ h5py/__init__.py
@@ -42,7 +42,8 @@
 
 from . import version
 
-from .tests import run_tests
+# W2DYNAMICS: Fix for broken installer
+# from .tests import run_tests
 
 __version__ = version.version
EOF
	$ENSURE_MPICC python setup.py install --user
        cd ../..
        just_did "installed python HDF5 interface (h5py)"
    fi
fi

# Currently not in use anyway (buggy)
#echo "Checking for FFTW library..."
#if ! gcc -lfftw3 -xc -o/dev/null - <<<"int main(){}"; then
#    if ask "The FFTW3 library was not found. Install?"; then
#        get_tarball http://www.fftw.org/fftw-3.3.3.tar.gz
#        install fftw-3.3.3 --with-pic
#    fi
#fi
#
#echo "Checking for NFFT library..."
#if ! gcc -lnfft3 -xc -o/dev/null - <<<"int main(){}"; then
#    if ask "The NFFT library was not found. Install?"; then
#	if ls -d $SOURCE_DIR/fftw* >/dev/null; then
#	    echo "Found local FFTW installation, using $INSTALL_DIR..."
#	    FFTW_CUSTOM=--with-fftw3=$INSTALL_DIR
#	fi
#        get_tarball http://www-user.tu-chemnitz.de/~potts/nfft/download/nfft-3.2.2.tar.gz
#        install nfft-3.2.2 $FFTW_CUSTOM
#	export USE_NFFT=1
#    fi
#else
#    export USE_NFFT=1
#fi

if ask "Install or update CT-QMC code?"; then
    if command -v ifort > /dev/null; then
        echo "Intel Fortran compiler ifort found. Going to use it to compile the program."
	export FC=ifort
    else
        echo "Intel Fortran compiler not found. Falling back to gfortran."
	export FC=gfortran
    fi
    cd $SCRIPT_DIR
    $PYTHON setup.py install --user
    rm -rf build
    rm -rf viscQMC.egg-info
    just_did "deployed CT-QMC code to python package repository"
fi

echo
echo "Complete. Things done:"
for thing in "${THINGS_DONE[@]}"; do
    echo " - $thing"
done
echo "You should log out and in again before running..."
